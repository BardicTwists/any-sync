syntax = "proto3";
option go_package = "paymentservice/paymentserviceproto";

// TODO: no marshalling avail :-(
//import "google/protobuf/timestamp.proto";

enum SubscriptionTier {
  TierUnknown = 0;

  // "free" tier
  TierExplorer = 1;

  // these can be used just for testing in debug mode
  // it will still create an active subscription, but with NO features
  TierBuilder1WeekTEST = 2;
  TierCoCreator1WeekTEST = 3;

  // these are the real tiers:
  TierBuilder1Year = 4;
  TierCoCreator1Year = 5;
}

enum SubscriptionStatus {
  StatusUnknown = 0;
  
  // payment is still pending
  // this will be the status until the payment is confirmed or N is elapsed and no payment is received
  // in the last case the subscription will switch to Status_Unknown or Status_Active
  StatusPending = 1;
  
  StatusActive = 2;  
}

enum PaymentMethod {
  MethodCard = 0;
  MethodCrypto = 1;
  MethodApplePay = 2;
  MethodGooglePay = 3;
}

// 1
message GetSubscriptionRequest {
  // in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
  // you can get it with Account().SignKey.GetPublic().Account()
  string ownerAnyID = 1;
}

message GetSubscriptionRequestSigned {
  // GetSubscriptionRequest
  bytes payload = 1;

  // this is payload signed with payload.ownerAnyID
  bytes signature = 2;
}

message GetSubscriptionResponse {
  SubscriptionTier tier = 1;
  SubscriptionStatus status = 2;

  //TODO: use google.protobuf.Timestamp and marshall it
  uint64 dateStarted = 3;
  uint64 dateEnds = 4;
  bool isAutoRenew = 5;

  // if client has "downgraded" - he is still able to use the service until the end of the period
  // (dateEnds) but then he will be on nextTier until nextTierEnds
  //
  // if Tier0_Unknown -> then no next tier
  SubscriptionTier nextTier = 6;
  uint64 nextTierEnds = 7;

  PaymentMethod paymentMethod = 8;

  string requestedAnyName = 9;

  // if user verified her email OR provided it while buying a subscription, it will be here
  string userEmail = 10;

  bool subscribeToNewsletter = 11;
}

// 2 
message BuySubscriptionRequest {
  // in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
  // you can get it with Account().SignKey.GetPublic().Account()
  string ownerAnyId = 1;

  // this is the owner's main EOA (Externally Owned Account) address
  // not AccountAbstraction's SCW (Smart Contract Wallet) address! 
  // this is required to reserve a name for the owner (later that is done by user)
  // in the following format: "0x7a250d5630b4cf539739df2c5dacb4c659f2488d"
  string ownerEthAddress = 2;

  SubscriptionTier requestedTier = 3;

  PaymentMethod paymentMethod = 4;

  // if empty - then no name requested
  // if non-empty - PP node will register that name on behalf of the user
  string requestedAnyName = 5;
}

message BuySubscriptionRequestSigned {
  // BuySubscriptionRequest
  bytes payload = 1;

  // this is payload signed with payload.ownerAnyID
  bytes signature = 2;
}

message BuySubscriptionResponse {
  // will feature current billing ID
  // stripe.com/?client_reference_id=1234
  string paymentUrl = 1;
}

message GetSubscriptionPortalLinkRequest {
  // in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
  // you can get it with Account().SignKey.GetPublic().Account()
  string ownerAnyId = 1;
}

message GetSubscriptionPortalLinkRequestSigned {
  // GetSubscriptionPortalLinkRequest
  bytes payload = 1;

  // this is payload signed with payload.ownerAnyID
  bytes signature = 2;
}

message GetSubscriptionPortalLinkResponse {
  string portalUrl = 1;
}

message GetVerificationEmailRequest {
  // in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
  // you can get it with Account().SignKey.GetPublic().Account()
  string ownerAnyId = 1;

  string email = 2;

  bool subscribeToNewsletter = 3;
}

message GetVerificationEmailResponse {
  
}

message GetVerificationEmailRequestSigned {
  // GetVerificationEmailRequest
  bytes payload = 1;

  // this is payload signed with payload.ownerAnyID
  bytes signature = 2;
}

message VerifyEmailRequest {
  // in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
  // you can get it with Account().SignKey.GetPublic().Account()
  string ownerAnyId = 1;

  // this is the owner's main EOA (Externally Owned Account) address
  // not AccountAbstraction's SCW (Smart Contract Wallet) address! 
  // this is required to reserve a name for the owner (later that is done by user)
  // in the following format: "0x7a250d5630b4cf539739df2c5dacb4c659f2488d"
  string ownerEthAddress = 2;
  
  string code = 3;
}

message VerifyEmailResponse {
  bool success = 1;
}

message VerifyEmailRequestSigned {
  // VerifyEmailRequest
  bytes payload = 1;

  // this is payload signed with payload.ownerAnyID
  bytes signature = 2;
}

// NOTICE:
// 1 - User can not ask for a payment/other links on behalf of another user (a signature is required)
// 2 - Admin can do that on behalf of any user
service AnyPaymentProcessing {
  rpc GetSubscriptionStatus(GetSubscriptionRequestSigned) returns (GetSubscriptionResponse) {}

  // Save a new BillingID to DB, and return a payment link.
  // You can call BuySubscription multiple times even if current payment is not processed yet 
  // (to get new payment link).
  // If user has already an active subscription, then this will return an error.
  rpc BuySubscription(BuySubscriptionRequestSigned) returns (BuySubscriptionResponse) {}

  // Generate a link to the portal where user can:
  // a) change her billing details
  // b) see payment info, invoices, etc
  // c) cancel/renew the subscription
  rpc GetSubscriptionPortalLink(GetSubscriptionPortalLinkRequestSigned) returns (GetSubscriptionPortalLinkResponse) {}

  // Verify user's email: 1st step - get a verification link to the email
  // Will fail if already verified, i.e. you can not change your email
  rpc GetVerificationEmail(GetVerificationEmailRequestSigned) returns (GetVerificationEmailResponse) {}
  
  // Enter the code from the email
  // Will fail if: link was not requested, link is expired, if email is already verified
  rpc VerifyEmail(VerifyEmailRequestSigned) returns (VerifyEmailResponse) {}
}

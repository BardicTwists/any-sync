// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paymentservice/paymentserviceproto/protos/paymentservice.proto

package paymentserviceproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SubscriptionTier int32

const (
	SubscriptionTier_Tier_Unknown        SubscriptionTier = 0
	SubscriptionTier_Tier_Friend         SubscriptionTier = 1
	SubscriptionTier_Tier_Supporter1Year SubscriptionTier = 2
	SubscriptionTier_Tier_Patron1Year    SubscriptionTier = 3
)

var SubscriptionTier_name = map[int32]string{
	0: "Tier_Unknown",
	1: "Tier_Friend",
	2: "Tier_Supporter1Year",
	3: "Tier_Patron1Year",
}

var SubscriptionTier_value = map[string]int32{
	"Tier_Unknown":        0,
	"Tier_Friend":         1,
	"Tier_Supporter1Year": 2,
	"Tier_Patron1Year":    3,
}

func (x SubscriptionTier) String() string {
	return proto.EnumName(SubscriptionTier_name, int32(x))
}

func (SubscriptionTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{0}
}

type SubscriptionStatus int32

const (
	SubscriptionStatus_Status_Unknown  SubscriptionStatus = 0
	SubscriptionStatus_Status_Pending  SubscriptionStatus = 1
	SubscriptionStatus_Status_Active   SubscriptionStatus = 2
	SubscriptionStatus_Status_Expired  SubscriptionStatus = 3
	SubscriptionStatus_Status_Canceled SubscriptionStatus = 4
)

var SubscriptionStatus_name = map[int32]string{
	0: "Status_Unknown",
	1: "Status_Pending",
	2: "Status_Active",
	3: "Status_Expired",
	4: "Status_Canceled",
}

var SubscriptionStatus_value = map[string]int32{
	"Status_Unknown":  0,
	"Status_Pending":  1,
	"Status_Active":   2,
	"Status_Expired":  3,
	"Status_Canceled": 4,
}

func (x SubscriptionStatus) String() string {
	return proto.EnumName(SubscriptionStatus_name, int32(x))
}

func (SubscriptionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{1}
}

type PaymentMethod int32

const (
	PaymentMethod_Method_Card      PaymentMethod = 0
	PaymentMethod_Method_Crypto    PaymentMethod = 1
	PaymentMethod_Method_ApplePay  PaymentMethod = 2
	PaymentMethod_Method_GooglePay PaymentMethod = 3
)

var PaymentMethod_name = map[int32]string{
	0: "Method_Card",
	1: "Method_Crypto",
	2: "Method_ApplePay",
	3: "Method_GooglePay",
}

var PaymentMethod_value = map[string]int32{
	"Method_Card":      0,
	"Method_Crypto":    1,
	"Method_ApplePay":  2,
	"Method_GooglePay": 3,
}

func (x PaymentMethod) String() string {
	return proto.EnumName(PaymentMethod_name, int32(x))
}

func (PaymentMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{2}
}

// 1
type GetSubscriptionRequest struct {
	// in the following format: "12D3KooWA8EXV3KjBxEU5EnsPfneLx84vMWAtTBQBeyooN82KSuS"
	OwnerAnyID string `protobuf:"bytes,1,opt,name=ownerAnyID,proto3" json:"ownerAnyID,omitempty"`
}

func (m *GetSubscriptionRequest) Reset()         { *m = GetSubscriptionRequest{} }
func (m *GetSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionRequest) ProtoMessage()    {}
func (*GetSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{0}
}
func (m *GetSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionRequest.Merge(m, src)
}
func (m *GetSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionRequest proto.InternalMessageInfo

func (m *GetSubscriptionRequest) GetOwnerAnyID() string {
	if m != nil {
		return m.OwnerAnyID
	}
	return ""
}

type GetSubscriptionRequestSigned struct {
	// GetSubscriptionRequest
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// this is payload signed with payload.ownerAnyID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *GetSubscriptionRequestSigned) Reset()         { *m = GetSubscriptionRequestSigned{} }
func (m *GetSubscriptionRequestSigned) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionRequestSigned) ProtoMessage()    {}
func (*GetSubscriptionRequestSigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{1}
}
func (m *GetSubscriptionRequestSigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionRequestSigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionRequestSigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionRequestSigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionRequestSigned.Merge(m, src)
}
func (m *GetSubscriptionRequestSigned) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionRequestSigned) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionRequestSigned.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionRequestSigned proto.InternalMessageInfo

func (m *GetSubscriptionRequestSigned) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *GetSubscriptionRequestSigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type GetSubscriptionResponse struct {
	Tier   SubscriptionTier   `protobuf:"varint,1,opt,name=tier,proto3,enum=SubscriptionTier" json:"tier,omitempty"`
	Status SubscriptionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=SubscriptionStatus" json:"status,omitempty"`
	// TODO: use google.protobuf.Timestamp and marshall it
	DateStarted uint64 `protobuf:"varint,3,opt,name=dateStarted,proto3" json:"dateStarted,omitempty"`
	DateEnds    uint64 `protobuf:"varint,4,opt,name=dateEnds,proto3" json:"dateEnds,omitempty"`
	IsAutoRenew bool   `protobuf:"varint,5,opt,name=isAutoRenew,proto3" json:"isAutoRenew,omitempty"`
	// if client has "downgraded" - he is still able to use the service until the end of the period
	// (dateEnds) but then he will be on nextTier until nextTierEnds
	//
	// if Tier0_Unknown -> then no next tier
	NextTier      SubscriptionTier `protobuf:"varint,6,opt,name=nextTier,proto3,enum=SubscriptionTier" json:"nextTier,omitempty"`
	NextTierEnds  uint64           `protobuf:"varint,7,opt,name=nextTierEnds,proto3" json:"nextTierEnds,omitempty"`
	PaymentMethod PaymentMethod    `protobuf:"varint,8,opt,name=paymentMethod,proto3,enum=PaymentMethod" json:"paymentMethod,omitempty"`
}

func (m *GetSubscriptionResponse) Reset()         { *m = GetSubscriptionResponse{} }
func (m *GetSubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionResponse) ProtoMessage()    {}
func (*GetSubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{2}
}
func (m *GetSubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionResponse.Merge(m, src)
}
func (m *GetSubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionResponse proto.InternalMessageInfo

func (m *GetSubscriptionResponse) GetTier() SubscriptionTier {
	if m != nil {
		return m.Tier
	}
	return SubscriptionTier_Tier_Unknown
}

func (m *GetSubscriptionResponse) GetStatus() SubscriptionStatus {
	if m != nil {
		return m.Status
	}
	return SubscriptionStatus_Status_Unknown
}

func (m *GetSubscriptionResponse) GetDateStarted() uint64 {
	if m != nil {
		return m.DateStarted
	}
	return 0
}

func (m *GetSubscriptionResponse) GetDateEnds() uint64 {
	if m != nil {
		return m.DateEnds
	}
	return 0
}

func (m *GetSubscriptionResponse) GetIsAutoRenew() bool {
	if m != nil {
		return m.IsAutoRenew
	}
	return false
}

func (m *GetSubscriptionResponse) GetNextTier() SubscriptionTier {
	if m != nil {
		return m.NextTier
	}
	return SubscriptionTier_Tier_Unknown
}

func (m *GetSubscriptionResponse) GetNextTierEnds() uint64 {
	if m != nil {
		return m.NextTierEnds
	}
	return 0
}

func (m *GetSubscriptionResponse) GetPaymentMethod() PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return PaymentMethod_Method_Card
}

// 2
type BuySubscriptionRequest struct {
	// in the following format: "12D3KooWA8EXV3KjBxEU5EnsPfneLx84vMWAtTBQBeyooN82KSuS"
	OwnerAnyID string `protobuf:"bytes,1,opt,name=ownerAnyID,proto3" json:"ownerAnyID,omitempty"`
	// this is the owner's ETH main EOA (External Owned Account) address
	//
	//	not AccountAbstraction's SCW (Smart Contract Wallet) address!
	//
	// in the following format: "0x7a250d5630b4cf539739df2c5dacb4c659f2488d"
	// this is required to reserve a name for the owner
	OwnerEthAddress string           `protobuf:"bytes,2,opt,name=ownerEthAddress,proto3" json:"ownerEthAddress,omitempty"`
	RequestedTier   SubscriptionTier `protobuf:"varint,3,opt,name=requestedTier,proto3,enum=SubscriptionTier" json:"requestedTier,omitempty"`
	PaymentMethod   PaymentMethod    `protobuf:"varint,4,opt,name=paymentMethod,proto3,enum=PaymentMethod" json:"paymentMethod,omitempty"`
}

func (m *BuySubscriptionRequest) Reset()         { *m = BuySubscriptionRequest{} }
func (m *BuySubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionRequest) ProtoMessage()    {}
func (*BuySubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{3}
}
func (m *BuySubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionRequest.Merge(m, src)
}
func (m *BuySubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionRequest proto.InternalMessageInfo

func (m *BuySubscriptionRequest) GetOwnerAnyID() string {
	if m != nil {
		return m.OwnerAnyID
	}
	return ""
}

func (m *BuySubscriptionRequest) GetOwnerEthAddress() string {
	if m != nil {
		return m.OwnerEthAddress
	}
	return ""
}

func (m *BuySubscriptionRequest) GetRequestedTier() SubscriptionTier {
	if m != nil {
		return m.RequestedTier
	}
	return SubscriptionTier_Tier_Unknown
}

func (m *BuySubscriptionRequest) GetPaymentMethod() PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return PaymentMethod_Method_Card
}

type BuySubscriptionRequestSigned struct {
	// BuySubscriptionRequest
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// this is payload signed with payload.ownerAnyID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BuySubscriptionRequestSigned) Reset()         { *m = BuySubscriptionRequestSigned{} }
func (m *BuySubscriptionRequestSigned) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionRequestSigned) ProtoMessage()    {}
func (*BuySubscriptionRequestSigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{4}
}
func (m *BuySubscriptionRequestSigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionRequestSigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionRequestSigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionRequestSigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionRequestSigned.Merge(m, src)
}
func (m *BuySubscriptionRequestSigned) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionRequestSigned) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionRequestSigned.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionRequestSigned proto.InternalMessageInfo

func (m *BuySubscriptionRequestSigned) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *BuySubscriptionRequestSigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type BuySubscriptionResponse struct {
	// will feature current billing ID
	// stripe.com/?client_reference_id=1234
	PaymentUrl string `protobuf:"bytes,1,opt,name=paymentUrl,proto3" json:"paymentUrl,omitempty"`
}

func (m *BuySubscriptionResponse) Reset()         { *m = BuySubscriptionResponse{} }
func (m *BuySubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionResponse) ProtoMessage()    {}
func (*BuySubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{5}
}
func (m *BuySubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionResponse.Merge(m, src)
}
func (m *BuySubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionResponse proto.InternalMessageInfo

func (m *BuySubscriptionResponse) GetPaymentUrl() string {
	if m != nil {
		return m.PaymentUrl
	}
	return ""
}

func init() {
	proto.RegisterEnum("SubscriptionTier", SubscriptionTier_name, SubscriptionTier_value)
	proto.RegisterEnum("SubscriptionStatus", SubscriptionStatus_name, SubscriptionStatus_value)
	proto.RegisterEnum("PaymentMethod", PaymentMethod_name, PaymentMethod_value)
	proto.RegisterType((*GetSubscriptionRequest)(nil), "GetSubscriptionRequest")
	proto.RegisterType((*GetSubscriptionRequestSigned)(nil), "GetSubscriptionRequestSigned")
	proto.RegisterType((*GetSubscriptionResponse)(nil), "GetSubscriptionResponse")
	proto.RegisterType((*BuySubscriptionRequest)(nil), "BuySubscriptionRequest")
	proto.RegisterType((*BuySubscriptionRequestSigned)(nil), "BuySubscriptionRequestSigned")
	proto.RegisterType((*BuySubscriptionResponse)(nil), "BuySubscriptionResponse")
}

func init() {
	proto.RegisterFile("paymentservice/paymentserviceproto/protos/paymentservice.proto", fileDescriptor_4feb29dcc5ba50f6)
}

var fileDescriptor_4feb29dcc5ba50f6 = []byte{
	// 647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0x51, 0x4b, 0x1b, 0x4b,
	0x14, 0xc7, 0x77, 0x93, 0x5c, 0x8d, 0x47, 0x93, 0xac, 0xa3, 0x57, 0x17, 0xd1, 0x25, 0x2c, 0x5c,
	0x08, 0x5e, 0xee, 0xca, 0xb5, 0x85, 0xb6, 0x50, 0x0a, 0xd1, 0x5a, 0x29, 0xb4, 0x10, 0x36, 0x55,
	0x68, 0x1f, 0x2a, 0x6b, 0xe6, 0x10, 0x97, 0xa6, 0x33, 0xdb, 0x99, 0x59, 0x75, 0xbf, 0x45, 0x3f,
	0x4e, 0x3f, 0x42, 0x1f, 0xed, 0x4b, 0xe9, 0x63, 0xd1, 0x2f, 0x52, 0x76, 0x76, 0xa3, 0x9b, 0xc4,
	0xd8, 0xd2, 0xbe, 0xec, 0xce, 0xf9, 0x9d, 0x33, 0xff, 0x99, 0xff, 0xcc, 0x61, 0xe0, 0x49, 0x14,
	0x24, 0xef, 0x91, 0x29, 0x89, 0xe2, 0x34, 0xec, 0xe1, 0xd6, 0x68, 0x18, 0x09, 0xae, 0xf8, 0x96,
	0xfe, 0xca, 0xb1, 0x94, 0xa7, 0xa9, 0xfb, 0x10, 0x56, 0xf6, 0x51, 0x75, 0xe3, 0x63, 0xd9, 0x13,
	0x61, 0xa4, 0x42, 0xce, 0x7c, 0xfc, 0x10, 0xa3, 0x54, 0xc4, 0x01, 0xe0, 0x67, 0x0c, 0x45, 0x9b,
	0x25, 0xcf, 0x9f, 0xda, 0x66, 0xd3, 0x6c, 0xcd, 0xf9, 0x05, 0xe2, 0x1e, 0xc2, 0xfa, 0xed, 0x33,
	0xbb, 0x61, 0x9f, 0x21, 0x25, 0x36, 0xcc, 0x46, 0x41, 0x32, 0xe0, 0x01, 0xd5, 0x93, 0x17, 0xfc,
	0x61, 0x48, 0xd6, 0x61, 0x4e, 0x86, 0x7d, 0x16, 0xa8, 0x58, 0xa0, 0x5d, 0xd2, 0xb9, 0x1b, 0xe0,
	0x7e, 0x2d, 0xc1, 0xea, 0x84, 0xb0, 0x8c, 0x38, 0x93, 0x48, 0xfe, 0x81, 0x8a, 0x0a, 0x51, 0x68,
	0xc1, 0xfa, 0xf6, 0xa2, 0x57, 0x2c, 0x7a, 0x15, 0xa2, 0xf0, 0x75, 0x9a, 0xfc, 0x0b, 0x33, 0x52,
	0x05, 0x2a, 0x96, 0x5a, 0xbd, 0xbe, 0xbd, 0x34, 0x52, 0xd8, 0xd5, 0x29, 0x3f, 0x2f, 0x21, 0x4d,
	0x98, 0xa7, 0x81, 0xc2, 0xae, 0x0a, 0x84, 0x42, 0x6a, 0x97, 0x9b, 0x66, 0xab, 0xe2, 0x17, 0x11,
	0x59, 0x83, 0x6a, 0x1a, 0xee, 0x31, 0x2a, 0xed, 0x8a, 0x4e, 0x5f, 0xc7, 0xe9, 0xec, 0x50, 0xb6,
	0x63, 0xc5, 0x7d, 0x64, 0x78, 0x66, 0xff, 0xd5, 0x34, 0x5b, 0x55, 0xbf, 0x88, 0xc8, 0x7f, 0x50,
	0x65, 0x78, 0xae, 0xd2, 0xed, 0xd9, 0x33, 0xd3, 0xf6, 0x7d, 0x5d, 0x42, 0x5c, 0x58, 0x18, 0x8e,
	0xf5, 0x82, 0xb3, 0x7a, 0xc1, 0x11, 0x46, 0xee, 0x43, 0x2d, 0xbf, 0xcc, 0x97, 0xa8, 0x4e, 0x38,
	0xb5, 0xab, 0x5a, 0xb7, 0xee, 0x75, 0x8a, 0xd4, 0x1f, 0x2d, 0x72, 0xbf, 0x98, 0xb0, 0xb2, 0x13,
	0x27, 0xbf, 0x71, 0xd7, 0xa4, 0x05, 0x0d, 0x1d, 0xed, 0xa9, 0x93, 0x36, 0xa5, 0x02, 0x65, 0x76,
	0xb2, 0x73, 0xfe, 0x38, 0x26, 0x0f, 0xa0, 0x26, 0x32, 0x51, 0xa4, 0xda, 0x72, 0x79, 0x9a, 0xe5,
	0xd1, 0xba, 0x49, 0x4f, 0x95, 0x5f, 0xf1, 0x74, 0x08, 0xeb, 0xb7, 0x5b, 0xfa, 0xc3, 0x26, 0x7c,
	0x04, 0xab, 0x13, 0xba, 0x79, 0x0f, 0x3a, 0x00, 0xf9, 0x1e, 0x0e, 0xc4, 0x60, 0x78, 0x56, 0x37,
	0x64, 0x93, 0x82, 0x35, 0xee, 0x95, 0x58, 0xb0, 0x90, 0xfe, 0x8f, 0x0e, 0xd8, 0x3b, 0xc6, 0xcf,
	0x98, 0x65, 0x90, 0x06, 0xcc, 0x6b, 0xf2, 0x4c, 0x84, 0xc8, 0xa8, 0x65, 0x92, 0x55, 0x58, 0xd2,
	0xa0, 0x1b, 0x47, 0x11, 0x17, 0x0a, 0xc5, 0xff, 0xaf, 0x31, 0x10, 0x56, 0x89, 0x2c, 0x83, 0xa5,
	0x13, 0x9d, 0x40, 0x09, 0xce, 0x32, 0x5a, 0xde, 0x3c, 0x07, 0x32, 0xd9, 0xd3, 0x84, 0x40, 0x3d,
	0x1b, 0x15, 0x56, 0xba, 0x61, 0x1d, 0x64, 0x34, 0x64, 0x7d, 0xcb, 0x24, 0x8b, 0x50, 0xcb, 0x59,
	0xbb, 0xa7, 0xc2, 0x53, 0xb4, 0x4a, 0x85, 0xb2, 0xbd, 0xf3, 0x28, 0x14, 0x48, 0xad, 0x32, 0x59,
	0x82, 0x46, 0xce, 0x76, 0x03, 0xd6, 0xc3, 0x01, 0x52, 0xab, 0xb2, 0xf9, 0x16, 0x6a, 0x23, 0x57,
	0x92, 0x5a, 0xc9, 0x46, 0x47, 0xbb, 0x81, 0xa0, 0x96, 0x91, 0xaa, 0x0f, 0x81, 0x48, 0x22, 0xc5,
	0x2d, 0x33, 0x55, 0xca, 0x51, 0x3b, 0x8a, 0x06, 0xd8, 0x09, 0x92, 0xcc, 0x59, 0x0e, 0xf7, 0x39,
	0xef, 0x67, 0xb4, 0xbc, 0xfd, 0xc9, 0x84, 0xe5, 0x36, 0x4b, 0xf2, 0x35, 0x3a, 0x82, 0xf7, 0x50,
	0xca, 0x90, 0xf5, 0x89, 0x0f, 0x7f, 0x8f, 0xbd, 0x0b, 0xb9, 0xeb, 0x0d, 0xef, 0xae, 0x87, 0x68,
	0xcd, 0xf6, 0xa6, 0x3c, 0x27, 0xae, 0x41, 0x5e, 0x40, 0x63, 0xec, 0x9e, 0xc9, 0x86, 0x77, 0x57,
	0x47, 0xad, 0xd9, 0xde, 0x94, 0xc6, 0x70, 0x8d, 0x9d, 0xc7, 0x9f, 0x2f, 0x1d, 0xf3, 0xe2, 0xd2,
	0x31, 0xbf, 0x5f, 0x3a, 0xe6, 0xc7, 0x2b, 0xc7, 0xb8, 0xb8, 0x72, 0x8c, 0x6f, 0x57, 0x8e, 0xf1,
	0xc6, 0xfd, 0xf9, 0x33, 0x7d, 0x3c, 0xa3, 0x7f, 0xf7, 0x7e, 0x04, 0x00, 0x00, 0xff, 0xff, 0xda,
	0x2c, 0x8d, 0x51, 0xd3, 0x05, 0x00, 0x00,
}

func (m *GetSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnerAnyID) > 0 {
		i -= len(m.OwnerAnyID)
		copy(dAtA[i:], m.OwnerAnyID)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerAnyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionRequestSigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionRequestSigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionRequestSigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PaymentMethod != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.PaymentMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.NextTierEnds != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.NextTierEnds))
		i--
		dAtA[i] = 0x38
	}
	if m.NextTier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.NextTier))
		i--
		dAtA[i] = 0x30
	}
	if m.IsAutoRenew {
		i--
		if m.IsAutoRenew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DateEnds != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.DateEnds))
		i--
		dAtA[i] = 0x20
	}
	if m.DateStarted != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.DateStarted))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Tier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PaymentMethod != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.PaymentMethod))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestedTier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.RequestedTier))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OwnerEthAddress) > 0 {
		i -= len(m.OwnerEthAddress)
		copy(dAtA[i:], m.OwnerEthAddress)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerEthAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OwnerAnyID) > 0 {
		i -= len(m.OwnerAnyID)
		copy(dAtA[i:], m.OwnerAnyID)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerAnyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionRequestSigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionRequestSigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionRequestSigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentUrl) > 0 {
		i -= len(m.PaymentUrl)
		copy(dAtA[i:], m.PaymentUrl)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.PaymentUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPaymentservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovPaymentservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerAnyID)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionRequestSigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tier != 0 {
		n += 1 + sovPaymentservice(uint64(m.Tier))
	}
	if m.Status != 0 {
		n += 1 + sovPaymentservice(uint64(m.Status))
	}
	if m.DateStarted != 0 {
		n += 1 + sovPaymentservice(uint64(m.DateStarted))
	}
	if m.DateEnds != 0 {
		n += 1 + sovPaymentservice(uint64(m.DateEnds))
	}
	if m.IsAutoRenew {
		n += 2
	}
	if m.NextTier != 0 {
		n += 1 + sovPaymentservice(uint64(m.NextTier))
	}
	if m.NextTierEnds != 0 {
		n += 1 + sovPaymentservice(uint64(m.NextTierEnds))
	}
	if m.PaymentMethod != 0 {
		n += 1 + sovPaymentservice(uint64(m.PaymentMethod))
	}
	return n
}

func (m *BuySubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerAnyID)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.OwnerEthAddress)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	if m.RequestedTier != 0 {
		n += 1 + sovPaymentservice(uint64(m.RequestedTier))
	}
	if m.PaymentMethod != 0 {
		n += 1 + sovPaymentservice(uint64(m.PaymentMethod))
	}
	return n
}

func (m *BuySubscriptionRequestSigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *BuySubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PaymentUrl)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func sovPaymentservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPaymentservice(x uint64) (n int) {
	return sovPaymentservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAnyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAnyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionRequestSigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionRequestSigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionRequestSigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SubscriptionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStarted", wireType)
			}
			m.DateStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateStarted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnds", wireType)
			}
			m.DateEnds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateEnds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAutoRenew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAutoRenew = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTier", wireType)
			}
			m.NextTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTierEnds", wireType)
			}
			m.NextTierEnds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTierEnds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			m.PaymentMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentMethod |= PaymentMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAnyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAnyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerEthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerEthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedTier", wireType)
			}
			m.RequestedTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedTier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			m.PaymentMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentMethod |= PaymentMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionRequestSigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionRequestSigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionRequestSigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPaymentservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPaymentservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPaymentservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPaymentservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPaymentservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPaymentservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPaymentservice = fmt.Errorf("proto: unexpected end of group")
)

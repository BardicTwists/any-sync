// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paymentservice/paymentserviceproto/protos/paymentservice.proto

package paymentserviceproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SubscriptionTier int32

const (
	SubscriptionTier_TierUnknown SubscriptionTier = 0
	// "free" tier
	SubscriptionTier_TierExplorer SubscriptionTier = 1
	// these can be used just for testing in debug mode
	// it will still create an active subscription, but with NO features
	SubscriptionTier_TierBuilder1WeekTEST   SubscriptionTier = 2
	SubscriptionTier_TierCoCreator1WeekTEST SubscriptionTier = 3
	// these are the real tiers:
	SubscriptionTier_TierBuilder1Year   SubscriptionTier = 4
	SubscriptionTier_TierCoCreator1Year SubscriptionTier = 5
)

var SubscriptionTier_name = map[int32]string{
	0: "TierUnknown",
	1: "TierExplorer",
	2: "TierBuilder1WeekTEST",
	3: "TierCoCreator1WeekTEST",
	4: "TierBuilder1Year",
	5: "TierCoCreator1Year",
}

var SubscriptionTier_value = map[string]int32{
	"TierUnknown":            0,
	"TierExplorer":           1,
	"TierBuilder1WeekTEST":   2,
	"TierCoCreator1WeekTEST": 3,
	"TierBuilder1Year":       4,
	"TierCoCreator1Year":     5,
}

func (x SubscriptionTier) String() string {
	return proto.EnumName(SubscriptionTier_name, int32(x))
}

func (SubscriptionTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{0}
}

type SubscriptionStatus int32

const (
	SubscriptionStatus_StatusUnknown SubscriptionStatus = 0
	// payment is still pending
	// this will be the status until the payment is confirmed or N is elapsed and no payment is received
	// in the last case the subscription will switch to Status_Unknown or Status_Active
	SubscriptionStatus_StatusPending SubscriptionStatus = 1
	SubscriptionStatus_StatusActive  SubscriptionStatus = 2
)

var SubscriptionStatus_name = map[int32]string{
	0: "StatusUnknown",
	1: "StatusPending",
	2: "StatusActive",
}

var SubscriptionStatus_value = map[string]int32{
	"StatusUnknown": 0,
	"StatusPending": 1,
	"StatusActive":  2,
}

func (x SubscriptionStatus) String() string {
	return proto.EnumName(SubscriptionStatus_name, int32(x))
}

func (SubscriptionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{1}
}

type PaymentMethod int32

const (
	PaymentMethod_MethodCard      PaymentMethod = 0
	PaymentMethod_MethodCrypto    PaymentMethod = 1
	PaymentMethod_MethodApplePay  PaymentMethod = 2
	PaymentMethod_MethodGooglePay PaymentMethod = 3
)

var PaymentMethod_name = map[int32]string{
	0: "MethodCard",
	1: "MethodCrypto",
	2: "MethodApplePay",
	3: "MethodGooglePay",
}

var PaymentMethod_value = map[string]int32{
	"MethodCard":      0,
	"MethodCrypto":    1,
	"MethodApplePay":  2,
	"MethodGooglePay": 3,
}

func (x PaymentMethod) String() string {
	return proto.EnumName(PaymentMethod_name, int32(x))
}

func (PaymentMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{2}
}

// 1
type GetSubscriptionRequest struct {
	// in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
	// you can get it with Account().SignKey.GetPublic().Account()
	OwnerAnyID string `protobuf:"bytes,1,opt,name=ownerAnyID,proto3" json:"ownerAnyID,omitempty"`
}

func (m *GetSubscriptionRequest) Reset()         { *m = GetSubscriptionRequest{} }
func (m *GetSubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionRequest) ProtoMessage()    {}
func (*GetSubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{0}
}
func (m *GetSubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionRequest.Merge(m, src)
}
func (m *GetSubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionRequest proto.InternalMessageInfo

func (m *GetSubscriptionRequest) GetOwnerAnyID() string {
	if m != nil {
		return m.OwnerAnyID
	}
	return ""
}

type GetSubscriptionRequestSigned struct {
	// GetSubscriptionRequest
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// this is payload signed with payload.ownerAnyID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *GetSubscriptionRequestSigned) Reset()         { *m = GetSubscriptionRequestSigned{} }
func (m *GetSubscriptionRequestSigned) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionRequestSigned) ProtoMessage()    {}
func (*GetSubscriptionRequestSigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{1}
}
func (m *GetSubscriptionRequestSigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionRequestSigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionRequestSigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionRequestSigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionRequestSigned.Merge(m, src)
}
func (m *GetSubscriptionRequestSigned) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionRequestSigned) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionRequestSigned.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionRequestSigned proto.InternalMessageInfo

func (m *GetSubscriptionRequestSigned) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *GetSubscriptionRequestSigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type GetSubscriptionResponse struct {
	Tier   SubscriptionTier   `protobuf:"varint,1,opt,name=tier,proto3,enum=SubscriptionTier" json:"tier,omitempty"`
	Status SubscriptionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=SubscriptionStatus" json:"status,omitempty"`
	// TODO: use google.protobuf.Timestamp and marshall it
	DateStarted uint64 `protobuf:"varint,3,opt,name=dateStarted,proto3" json:"dateStarted,omitempty"`
	DateEnds    uint64 `protobuf:"varint,4,opt,name=dateEnds,proto3" json:"dateEnds,omitempty"`
	IsAutoRenew bool   `protobuf:"varint,5,opt,name=isAutoRenew,proto3" json:"isAutoRenew,omitempty"`
	// if client has "downgraded" - he is still able to use the service until the end of the period
	// (dateEnds) but then he will be on nextTier until nextTierEnds
	//
	// if Tier0_Unknown -> then no next tier
	NextTier      SubscriptionTier `protobuf:"varint,6,opt,name=nextTier,proto3,enum=SubscriptionTier" json:"nextTier,omitempty"`
	NextTierEnds  uint64           `protobuf:"varint,7,opt,name=nextTierEnds,proto3" json:"nextTierEnds,omitempty"`
	PaymentMethod PaymentMethod    `protobuf:"varint,8,opt,name=paymentMethod,proto3,enum=PaymentMethod" json:"paymentMethod,omitempty"`
	// if name was requested - it will be here
	// seeBuySubscriptionRequest.requestedAnyName field
	RequestedAnyName string `protobuf:"bytes,9,opt,name=requestedAnyName,proto3" json:"requestedAnyName,omitempty"`
}

func (m *GetSubscriptionResponse) Reset()         { *m = GetSubscriptionResponse{} }
func (m *GetSubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionResponse) ProtoMessage()    {}
func (*GetSubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{2}
}
func (m *GetSubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionResponse.Merge(m, src)
}
func (m *GetSubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionResponse proto.InternalMessageInfo

func (m *GetSubscriptionResponse) GetTier() SubscriptionTier {
	if m != nil {
		return m.Tier
	}
	return SubscriptionTier_TierUnknown
}

func (m *GetSubscriptionResponse) GetStatus() SubscriptionStatus {
	if m != nil {
		return m.Status
	}
	return SubscriptionStatus_StatusUnknown
}

func (m *GetSubscriptionResponse) GetDateStarted() uint64 {
	if m != nil {
		return m.DateStarted
	}
	return 0
}

func (m *GetSubscriptionResponse) GetDateEnds() uint64 {
	if m != nil {
		return m.DateEnds
	}
	return 0
}

func (m *GetSubscriptionResponse) GetIsAutoRenew() bool {
	if m != nil {
		return m.IsAutoRenew
	}
	return false
}

func (m *GetSubscriptionResponse) GetNextTier() SubscriptionTier {
	if m != nil {
		return m.NextTier
	}
	return SubscriptionTier_TierUnknown
}

func (m *GetSubscriptionResponse) GetNextTierEnds() uint64 {
	if m != nil {
		return m.NextTierEnds
	}
	return 0
}

func (m *GetSubscriptionResponse) GetPaymentMethod() PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return PaymentMethod_MethodCard
}

func (m *GetSubscriptionResponse) GetRequestedAnyName() string {
	if m != nil {
		return m.RequestedAnyName
	}
	return ""
}

// 2
type BuySubscriptionRequest struct {
	// in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
	// you can get it with Account().SignKey.GetPublic().Account()
	OwnerAnyId string `protobuf:"bytes,1,opt,name=ownerAnyId,proto3" json:"ownerAnyId,omitempty"`
	// this is the owner's main EOA (Externally Owned Account) address
	// not AccountAbstraction's SCW (Smart Contract Wallet) address!
	// this is required to reserve a name for the owner (later that is done by user)
	// in the following format: "0x7a250d5630b4cf539739df2c5dacb4c659f2488d"
	OwnerEthAddress string           `protobuf:"bytes,2,opt,name=ownerEthAddress,proto3" json:"ownerEthAddress,omitempty"`
	RequestedTier   SubscriptionTier `protobuf:"varint,3,opt,name=requestedTier,proto3,enum=SubscriptionTier" json:"requestedTier,omitempty"`
	PaymentMethod   PaymentMethod    `protobuf:"varint,4,opt,name=paymentMethod,proto3,enum=PaymentMethod" json:"paymentMethod,omitempty"`
	// this is just to store the requested name in the DB
	// and then you will be able to retrieve it via GetSubscriptionRequest
	// PP won't register the name in NS!
	RequestedAnyName string `protobuf:"bytes,5,opt,name=requestedAnyName,proto3" json:"requestedAnyName,omitempty"`
}

func (m *BuySubscriptionRequest) Reset()         { *m = BuySubscriptionRequest{} }
func (m *BuySubscriptionRequest) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionRequest) ProtoMessage()    {}
func (*BuySubscriptionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{3}
}
func (m *BuySubscriptionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionRequest.Merge(m, src)
}
func (m *BuySubscriptionRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionRequest proto.InternalMessageInfo

func (m *BuySubscriptionRequest) GetOwnerAnyId() string {
	if m != nil {
		return m.OwnerAnyId
	}
	return ""
}

func (m *BuySubscriptionRequest) GetOwnerEthAddress() string {
	if m != nil {
		return m.OwnerEthAddress
	}
	return ""
}

func (m *BuySubscriptionRequest) GetRequestedTier() SubscriptionTier {
	if m != nil {
		return m.RequestedTier
	}
	return SubscriptionTier_TierUnknown
}

func (m *BuySubscriptionRequest) GetPaymentMethod() PaymentMethod {
	if m != nil {
		return m.PaymentMethod
	}
	return PaymentMethod_MethodCard
}

func (m *BuySubscriptionRequest) GetRequestedAnyName() string {
	if m != nil {
		return m.RequestedAnyName
	}
	return ""
}

type BuySubscriptionRequestSigned struct {
	// BuySubscriptionRequest
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// this is payload signed with payload.ownerAnyID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BuySubscriptionRequestSigned) Reset()         { *m = BuySubscriptionRequestSigned{} }
func (m *BuySubscriptionRequestSigned) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionRequestSigned) ProtoMessage()    {}
func (*BuySubscriptionRequestSigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{4}
}
func (m *BuySubscriptionRequestSigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionRequestSigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionRequestSigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionRequestSigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionRequestSigned.Merge(m, src)
}
func (m *BuySubscriptionRequestSigned) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionRequestSigned) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionRequestSigned.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionRequestSigned proto.InternalMessageInfo

func (m *BuySubscriptionRequestSigned) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *BuySubscriptionRequestSigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type BuySubscriptionResponse struct {
	// will feature current billing ID
	// stripe.com/?client_reference_id=1234
	PaymentUrl string `protobuf:"bytes,1,opt,name=paymentUrl,proto3" json:"paymentUrl,omitempty"`
}

func (m *BuySubscriptionResponse) Reset()         { *m = BuySubscriptionResponse{} }
func (m *BuySubscriptionResponse) String() string { return proto.CompactTextString(m) }
func (*BuySubscriptionResponse) ProtoMessage()    {}
func (*BuySubscriptionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{5}
}
func (m *BuySubscriptionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuySubscriptionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuySubscriptionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuySubscriptionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuySubscriptionResponse.Merge(m, src)
}
func (m *BuySubscriptionResponse) XXX_Size() int {
	return m.Size()
}
func (m *BuySubscriptionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BuySubscriptionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BuySubscriptionResponse proto.InternalMessageInfo

func (m *BuySubscriptionResponse) GetPaymentUrl() string {
	if m != nil {
		return m.PaymentUrl
	}
	return ""
}

type GetSubscriptionPortalLinkRequest struct {
	// in the following format: "A5k2d9sFZw84yisTxRnz2bPRd1YPfVfhxqymZ6yESprFTG65"
	// you can get it with Account().SignKey.GetPublic().Account()
	OwnerAnyId string `protobuf:"bytes,1,opt,name=ownerAnyId,proto3" json:"ownerAnyId,omitempty"`
}

func (m *GetSubscriptionPortalLinkRequest) Reset()         { *m = GetSubscriptionPortalLinkRequest{} }
func (m *GetSubscriptionPortalLinkRequest) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionPortalLinkRequest) ProtoMessage()    {}
func (*GetSubscriptionPortalLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{6}
}
func (m *GetSubscriptionPortalLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionPortalLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionPortalLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionPortalLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionPortalLinkRequest.Merge(m, src)
}
func (m *GetSubscriptionPortalLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionPortalLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionPortalLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionPortalLinkRequest proto.InternalMessageInfo

func (m *GetSubscriptionPortalLinkRequest) GetOwnerAnyId() string {
	if m != nil {
		return m.OwnerAnyId
	}
	return ""
}

type GetSubscriptionPortalLinkRequestSigned struct {
	// GetSubscriptionPortalLinkRequest
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// this is payload signed with payload.ownerAnyID
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *GetSubscriptionPortalLinkRequestSigned) Reset() {
	*m = GetSubscriptionPortalLinkRequestSigned{}
}
func (m *GetSubscriptionPortalLinkRequestSigned) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionPortalLinkRequestSigned) ProtoMessage()    {}
func (*GetSubscriptionPortalLinkRequestSigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{7}
}
func (m *GetSubscriptionPortalLinkRequestSigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionPortalLinkRequestSigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionPortalLinkRequestSigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionPortalLinkRequestSigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionPortalLinkRequestSigned.Merge(m, src)
}
func (m *GetSubscriptionPortalLinkRequestSigned) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionPortalLinkRequestSigned) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionPortalLinkRequestSigned.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionPortalLinkRequestSigned proto.InternalMessageInfo

func (m *GetSubscriptionPortalLinkRequestSigned) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *GetSubscriptionPortalLinkRequestSigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type GetSubscriptionPortalLinkResponse struct {
	PortalUrl string `protobuf:"bytes,1,opt,name=portalUrl,proto3" json:"portalUrl,omitempty"`
}

func (m *GetSubscriptionPortalLinkResponse) Reset()         { *m = GetSubscriptionPortalLinkResponse{} }
func (m *GetSubscriptionPortalLinkResponse) String() string { return proto.CompactTextString(m) }
func (*GetSubscriptionPortalLinkResponse) ProtoMessage()    {}
func (*GetSubscriptionPortalLinkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4feb29dcc5ba50f6, []int{8}
}
func (m *GetSubscriptionPortalLinkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSubscriptionPortalLinkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSubscriptionPortalLinkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSubscriptionPortalLinkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSubscriptionPortalLinkResponse.Merge(m, src)
}
func (m *GetSubscriptionPortalLinkResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSubscriptionPortalLinkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSubscriptionPortalLinkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSubscriptionPortalLinkResponse proto.InternalMessageInfo

func (m *GetSubscriptionPortalLinkResponse) GetPortalUrl() string {
	if m != nil {
		return m.PortalUrl
	}
	return ""
}

func init() {
	proto.RegisterEnum("SubscriptionTier", SubscriptionTier_name, SubscriptionTier_value)
	proto.RegisterEnum("SubscriptionStatus", SubscriptionStatus_name, SubscriptionStatus_value)
	proto.RegisterEnum("PaymentMethod", PaymentMethod_name, PaymentMethod_value)
	proto.RegisterType((*GetSubscriptionRequest)(nil), "GetSubscriptionRequest")
	proto.RegisterType((*GetSubscriptionRequestSigned)(nil), "GetSubscriptionRequestSigned")
	proto.RegisterType((*GetSubscriptionResponse)(nil), "GetSubscriptionResponse")
	proto.RegisterType((*BuySubscriptionRequest)(nil), "BuySubscriptionRequest")
	proto.RegisterType((*BuySubscriptionRequestSigned)(nil), "BuySubscriptionRequestSigned")
	proto.RegisterType((*BuySubscriptionResponse)(nil), "BuySubscriptionResponse")
	proto.RegisterType((*GetSubscriptionPortalLinkRequest)(nil), "GetSubscriptionPortalLinkRequest")
	proto.RegisterType((*GetSubscriptionPortalLinkRequestSigned)(nil), "GetSubscriptionPortalLinkRequestSigned")
	proto.RegisterType((*GetSubscriptionPortalLinkResponse)(nil), "GetSubscriptionPortalLinkResponse")
}

func init() {
	proto.RegisterFile("paymentservice/paymentserviceproto/protos/paymentservice.proto", fileDescriptor_4feb29dcc5ba50f6)
}

var fileDescriptor_4feb29dcc5ba50f6 = []byte{
	// 738 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xcf, 0x4f, 0xdb, 0x48,
	0x14, 0xc7, 0xe3, 0x24, 0x40, 0xf2, 0x20, 0x89, 0x19, 0xd8, 0xe0, 0x8d, 0x82, 0x95, 0xb5, 0xb4,
	0xbb, 0x51, 0x56, 0x6b, 0xb4, 0x6c, 0xa5, 0xb6, 0x52, 0x55, 0xc9, 0xa1, 0x08, 0x55, 0xa2, 0x55,
	0xe4, 0x00, 0x55, 0x39, 0xd5, 0xc4, 0x4f, 0xc1, 0x25, 0xcc, 0xb8, 0xe3, 0x09, 0xe0, 0x6b, 0xff,
	0x82, 0x5e, 0x7b, 0xef, 0x1f, 0xd3, 0x23, 0xc7, 0x1e, 0x2b, 0xf8, 0x3b, 0x2a, 0x55, 0x19, 0x9b,
	0xfc, 0x24, 0x04, 0x95, 0x4b, 0x3c, 0xef, 0xf3, 0xde, 0xbc, 0x99, 0x37, 0xef, 0x3b, 0x13, 0x78,
	0xee, 0x3b, 0xe1, 0x29, 0x52, 0x11, 0x20, 0x3f, 0xf3, 0x5a, 0xb8, 0x31, 0x6a, 0xfa, 0x9c, 0x09,
	0xb6, 0x21, 0x7f, 0x83, 0x31, 0x97, 0x29, 0xa9, 0xf1, 0x04, 0x8a, 0x3b, 0x28, 0x9a, 0xdd, 0xa3,
	0xa0, 0xc5, 0x3d, 0x5f, 0x78, 0x8c, 0xda, 0xf8, 0xa1, 0x8b, 0x81, 0x20, 0x3a, 0x00, 0x3b, 0xa7,
	0xc8, 0x2d, 0x1a, 0xbe, 0x7c, 0xa1, 0x29, 0x15, 0xa5, 0x9a, 0xb5, 0x87, 0x88, 0x71, 0x00, 0xe5,
	0xdb, 0x67, 0x36, 0xbd, 0x36, 0x45, 0x97, 0x68, 0xb0, 0xe0, 0x3b, 0x61, 0x87, 0x39, 0xae, 0x9c,
	0xbc, 0x64, 0xdf, 0x98, 0xa4, 0x0c, 0xd9, 0xc0, 0x6b, 0x53, 0x47, 0x74, 0x39, 0x6a, 0x49, 0xe9,
	0x1b, 0x00, 0xe3, 0x63, 0x0a, 0xd6, 0x26, 0x12, 0x07, 0x3e, 0xa3, 0x01, 0x92, 0x3f, 0x21, 0x2d,
	0x3c, 0xe4, 0x32, 0x61, 0x7e, 0x73, 0xd9, 0x1c, 0x0e, 0xda, 0xf3, 0x90, 0xdb, 0xd2, 0x4d, 0xfe,
	0x81, 0xf9, 0x40, 0x38, 0xa2, 0x1b, 0xc8, 0xec, 0xf9, 0xcd, 0x95, 0x91, 0xc0, 0xa6, 0x74, 0xd9,
	0x71, 0x08, 0xa9, 0xc0, 0xa2, 0xeb, 0x08, 0x6c, 0x0a, 0x87, 0x0b, 0x74, 0xb5, 0x54, 0x45, 0xa9,
	0xa6, 0xed, 0x61, 0x44, 0x4a, 0x90, 0xe9, 0x99, 0xdb, 0xd4, 0x0d, 0xb4, 0xb4, 0x74, 0xf7, 0xed,
	0xde, 0x6c, 0x2f, 0xb0, 0xba, 0x82, 0xd9, 0x48, 0xf1, 0x5c, 0x9b, 0xab, 0x28, 0xd5, 0x8c, 0x3d,
	0x8c, 0xc8, 0xbf, 0x90, 0xa1, 0x78, 0x21, 0x7a, 0xdb, 0xd3, 0xe6, 0xa7, 0xed, 0xbb, 0x1f, 0x42,
	0x0c, 0x58, 0xba, 0x19, 0xcb, 0x05, 0x17, 0xe4, 0x82, 0x23, 0x8c, 0x3c, 0x82, 0x5c, 0xdc, 0xcc,
	0x57, 0x28, 0x8e, 0x99, 0xab, 0x65, 0x64, 0xde, 0xbc, 0xd9, 0x18, 0xa6, 0xf6, 0x68, 0x10, 0xa9,
	0x81, 0xca, 0xa3, 0x0e, 0xa1, 0x6b, 0xd1, 0xf0, 0xb5, 0x73, 0x8a, 0x5a, 0x56, 0xb6, 0x75, 0x82,
	0x1b, 0x3f, 0x14, 0x28, 0xd6, 0xbb, 0xe1, 0x2c, 0x5d, 0xb8, 0x13, 0xba, 0x70, 0x49, 0x15, 0x0a,
	0xd2, 0xda, 0x16, 0xc7, 0x96, 0xeb, 0x72, 0x0c, 0xa2, 0x2e, 0x64, 0xed, 0x71, 0x4c, 0x1e, 0x43,
	0xae, 0xbf, 0xb0, 0x3c, 0x9e, 0xd4, 0xb4, 0xe3, 0x19, 0x8d, 0x9b, 0xac, 0x3f, 0xfd, 0xab, 0xf5,
	0xcf, 0x4d, 0xa9, 0xff, 0x00, 0xca, 0xb7, 0x97, 0xff, 0x40, 0x71, 0x3f, 0x85, 0xb5, 0x89, 0xbc,
	0xb1, 0xb6, 0x75, 0x80, 0x78, 0xbf, 0xfb, 0xbc, 0x73, 0x73, 0xae, 0x03, 0x62, 0xd4, 0xa1, 0x32,
	0x76, 0x2d, 0x1a, 0x8c, 0x0b, 0xa7, 0xb3, 0xeb, 0xd1, 0x93, 0x7b, 0xf6, 0xc6, 0x78, 0x07, 0x7f,
	0xcd, 0xca, 0xf1, 0xc0, 0x02, 0x2d, 0xf8, 0xe3, 0x8e, 0x15, 0xe2, 0x52, 0xcb, 0x90, 0xf5, 0x25,
	0x1d, 0x54, 0x3a, 0x00, 0xb5, 0xcf, 0x0a, 0xa8, 0xe3, 0x0a, 0x20, 0x05, 0x58, 0xec, 0x7d, 0xf7,
	0xe9, 0x09, 0x65, 0xe7, 0x54, 0x4d, 0x10, 0x15, 0x96, 0xe4, 0x7d, 0xb8, 0xf0, 0x3b, 0x8c, 0x23,
	0x57, 0x15, 0xa2, 0xc1, 0x6a, 0x8f, 0xd4, 0xbb, 0x5e, 0xc7, 0x45, 0xfe, 0xdf, 0x1b, 0xc4, 0x93,
	0xbd, 0xed, 0xe6, 0x9e, 0x9a, 0x24, 0x25, 0x28, 0xf6, 0x3c, 0x5b, 0x6c, 0x8b, 0xa3, 0x23, 0xd8,
	0x90, 0x2f, 0x45, 0x56, 0x41, 0x1d, 0x9e, 0xf5, 0x16, 0x1d, 0xae, 0xa6, 0x49, 0x11, 0xc8, 0xe8,
	0x0c, 0xc9, 0xe7, 0x6a, 0xbb, 0x40, 0x26, 0x9f, 0x12, 0xb2, 0x0c, 0xb9, 0x68, 0x34, 0xd8, 0x5e,
	0x1f, 0x35, 0x90, 0xba, 0x1e, 0x6d, 0xab, 0x4a, 0x6f, 0xc7, 0x11, 0xb2, 0x5a, 0xc2, 0x3b, 0x43,
	0x35, 0x59, 0x3b, 0x84, 0xdc, 0x88, 0x62, 0x49, 0x1e, 0x20, 0x1a, 0x6d, 0x39, 0xdc, 0x8d, 0x8a,
	0x8c, 0x6d, 0x1e, 0xfa, 0x82, 0xa9, 0x0a, 0x21, 0x90, 0x8f, 0x88, 0xe5, 0xfb, 0x1d, 0x6c, 0x38,
	0xa1, 0x9a, 0x24, 0x2b, 0x50, 0x88, 0xd8, 0x0e, 0x63, 0xed, 0x08, 0xa6, 0x36, 0xbf, 0x24, 0x61,
	0xd5, 0xa2, 0x61, 0x9c, 0xbf, 0xc1, 0x59, 0x0b, 0x83, 0xc0, 0xa3, 0x6d, 0x62, 0xc3, 0x6f, 0x63,
	0x1d, 0x8a, 0xab, 0x58, 0x37, 0xef, 0x7a, 0xcf, 0x4b, 0x9a, 0x39, 0xe5, 0x55, 0x36, 0x12, 0x64,
	0x17, 0x0a, 0x63, 0xb2, 0x26, 0xeb, 0xe6, 0x5d, 0x17, 0xa8, 0xa4, 0x99, 0x53, 0xee, 0x81, 0x91,
	0x20, 0xef, 0xe1, 0xf7, 0xa9, 0x1a, 0x22, 0x7f, 0x9b, 0xf7, 0x53, 0x70, 0xc9, 0x30, 0x67, 0x0a,
	0xd1, 0x48, 0xd4, 0x9f, 0x7d, 0xbd, 0xd2, 0x95, 0xcb, 0x2b, 0x5d, 0xf9, 0x7e, 0xa5, 0x2b, 0x9f,
	0xae, 0xf5, 0xc4, 0xe5, 0xb5, 0x9e, 0xf8, 0x76, 0xad, 0x27, 0x0e, 0x8d, 0xd9, 0xff, 0xac, 0x47,
	0xf3, 0xf2, 0xf3, 0xff, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x04, 0x54, 0x62, 0x82, 0x86, 0x07,
	0x00, 0x00,
}

func (m *GetSubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnerAnyID) > 0 {
		i -= len(m.OwnerAnyID)
		copy(dAtA[i:], m.OwnerAnyID)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerAnyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionRequestSigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionRequestSigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionRequestSigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestedAnyName) > 0 {
		i -= len(m.RequestedAnyName)
		copy(dAtA[i:], m.RequestedAnyName)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.RequestedAnyName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PaymentMethod != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.PaymentMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.NextTierEnds != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.NextTierEnds))
		i--
		dAtA[i] = 0x38
	}
	if m.NextTier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.NextTier))
		i--
		dAtA[i] = 0x30
	}
	if m.IsAutoRenew {
		i--
		if m.IsAutoRenew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DateEnds != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.DateEnds))
		i--
		dAtA[i] = 0x20
	}
	if m.DateStarted != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.DateStarted))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Tier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestedAnyName) > 0 {
		i -= len(m.RequestedAnyName)
		copy(dAtA[i:], m.RequestedAnyName)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.RequestedAnyName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PaymentMethod != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.PaymentMethod))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestedTier != 0 {
		i = encodeVarintPaymentservice(dAtA, i, uint64(m.RequestedTier))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OwnerEthAddress) > 0 {
		i -= len(m.OwnerEthAddress)
		copy(dAtA[i:], m.OwnerEthAddress)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerEthAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OwnerAnyId) > 0 {
		i -= len(m.OwnerAnyId)
		copy(dAtA[i:], m.OwnerAnyId)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerAnyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionRequestSigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionRequestSigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionRequestSigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuySubscriptionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySubscriptionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuySubscriptionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentUrl) > 0 {
		i -= len(m.PaymentUrl)
		copy(dAtA[i:], m.PaymentUrl)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.PaymentUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionPortalLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionPortalLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionPortalLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnerAnyId) > 0 {
		i -= len(m.OwnerAnyId)
		copy(dAtA[i:], m.OwnerAnyId)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.OwnerAnyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionPortalLinkRequestSigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionPortalLinkRequestSigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionPortalLinkRequestSigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSubscriptionPortalLinkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSubscriptionPortalLinkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSubscriptionPortalLinkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PortalUrl) > 0 {
		i -= len(m.PortalUrl)
		copy(dAtA[i:], m.PortalUrl)
		i = encodeVarintPaymentservice(dAtA, i, uint64(len(m.PortalUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPaymentservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovPaymentservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetSubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerAnyID)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionRequestSigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tier != 0 {
		n += 1 + sovPaymentservice(uint64(m.Tier))
	}
	if m.Status != 0 {
		n += 1 + sovPaymentservice(uint64(m.Status))
	}
	if m.DateStarted != 0 {
		n += 1 + sovPaymentservice(uint64(m.DateStarted))
	}
	if m.DateEnds != 0 {
		n += 1 + sovPaymentservice(uint64(m.DateEnds))
	}
	if m.IsAutoRenew {
		n += 2
	}
	if m.NextTier != 0 {
		n += 1 + sovPaymentservice(uint64(m.NextTier))
	}
	if m.NextTierEnds != 0 {
		n += 1 + sovPaymentservice(uint64(m.NextTierEnds))
	}
	if m.PaymentMethod != 0 {
		n += 1 + sovPaymentservice(uint64(m.PaymentMethod))
	}
	l = len(m.RequestedAnyName)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *BuySubscriptionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerAnyId)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.OwnerEthAddress)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	if m.RequestedTier != 0 {
		n += 1 + sovPaymentservice(uint64(m.RequestedTier))
	}
	if m.PaymentMethod != 0 {
		n += 1 + sovPaymentservice(uint64(m.PaymentMethod))
	}
	l = len(m.RequestedAnyName)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *BuySubscriptionRequestSigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *BuySubscriptionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PaymentUrl)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionPortalLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OwnerAnyId)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionPortalLinkRequestSigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func (m *GetSubscriptionPortalLinkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortalUrl)
	if l > 0 {
		n += 1 + l + sovPaymentservice(uint64(l))
	}
	return n
}

func sovPaymentservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPaymentservice(x uint64) (n int) {
	return sovPaymentservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetSubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAnyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAnyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionRequestSigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionRequestSigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionRequestSigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SubscriptionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStarted", wireType)
			}
			m.DateStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateStarted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnds", wireType)
			}
			m.DateEnds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateEnds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAutoRenew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAutoRenew = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTier", wireType)
			}
			m.NextTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTierEnds", wireType)
			}
			m.NextTierEnds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTierEnds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			m.PaymentMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentMethod |= PaymentMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAnyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedAnyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAnyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAnyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerEthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerEthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedTier", wireType)
			}
			m.RequestedTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedTier |= SubscriptionTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			m.PaymentMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentMethod |= PaymentMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAnyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedAnyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionRequestSigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionRequestSigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionRequestSigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySubscriptionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySubscriptionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySubscriptionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionPortalLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAnyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAnyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionPortalLinkRequestSigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkRequestSigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkRequestSigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSubscriptionPortalLinkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSubscriptionPortalLinkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortalUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaymentservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortalUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaymentservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaymentservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPaymentservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPaymentservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaymentservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPaymentservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPaymentservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPaymentservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPaymentservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPaymentservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPaymentservice = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: commonspace/object/acl/aclrecordproto/protos/aclrecord.proto

package aclrecordproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AclUserPermissions contains different possible user roles
type AclUserPermissions int32

const (
	AclUserPermissions_None   AclUserPermissions = 0
	AclUserPermissions_Owner  AclUserPermissions = 1
	AclUserPermissions_Admin  AclUserPermissions = 2
	AclUserPermissions_Writer AclUserPermissions = 3
	AclUserPermissions_Reader AclUserPermissions = 4
)

var AclUserPermissions_name = map[int32]string{
	0: "None",
	1: "Owner",
	2: "Admin",
	3: "Writer",
	4: "Reader",
}

var AclUserPermissions_value = map[string]int32{
	"None":   0,
	"Owner":  1,
	"Admin":  2,
	"Writer": 3,
	"Reader": 4,
}

func (x AclUserPermissions) String() string {
	return proto.EnumName(AclUserPermissions_name, int32(x))
}

func (AclUserPermissions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{0}
}

// RawAclRecord is a proto message containing the acl payload in bytes, signature of the account who added it and signature of the acceptor
type RawAclRecord struct {
	Payload           []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signature         []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	AcceptorIdentity  []byte `protobuf:"bytes,3,opt,name=acceptorIdentity,proto3" json:"acceptorIdentity,omitempty"`
	AcceptorSignature []byte `protobuf:"bytes,4,opt,name=acceptorSignature,proto3" json:"acceptorSignature,omitempty"`
}

func (m *RawAclRecord) Reset()         { *m = RawAclRecord{} }
func (m *RawAclRecord) String() string { return proto.CompactTextString(m) }
func (*RawAclRecord) ProtoMessage()    {}
func (*RawAclRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{0}
}
func (m *RawAclRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawAclRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawAclRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawAclRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawAclRecord.Merge(m, src)
}
func (m *RawAclRecord) XXX_Size() int {
	return m.Size()
}
func (m *RawAclRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_RawAclRecord.DiscardUnknown(m)
}

var xxx_messageInfo_RawAclRecord proto.InternalMessageInfo

func (m *RawAclRecord) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *RawAclRecord) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *RawAclRecord) GetAcceptorIdentity() []byte {
	if m != nil {
		return m.AcceptorIdentity
	}
	return nil
}

func (m *RawAclRecord) GetAcceptorSignature() []byte {
	if m != nil {
		return m.AcceptorSignature
	}
	return nil
}

// RawAclRecordWithId is a raw record and the id for convenience
type RawAclRecordWithId struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Id      string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RawAclRecordWithId) Reset()         { *m = RawAclRecordWithId{} }
func (m *RawAclRecordWithId) String() string { return proto.CompactTextString(m) }
func (*RawAclRecordWithId) ProtoMessage()    {}
func (*RawAclRecordWithId) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{1}
}
func (m *RawAclRecordWithId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawAclRecordWithId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawAclRecordWithId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawAclRecordWithId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawAclRecordWithId.Merge(m, src)
}
func (m *RawAclRecordWithId) XXX_Size() int {
	return m.Size()
}
func (m *RawAclRecordWithId) XXX_DiscardUnknown() {
	xxx_messageInfo_RawAclRecordWithId.DiscardUnknown(m)
}

var xxx_messageInfo_RawAclRecordWithId proto.InternalMessageInfo

func (m *RawAclRecordWithId) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *RawAclRecordWithId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// AclRecord is a record containing the acl data
type AclRecord struct {
	PrevId    string `protobuf:"bytes,1,opt,name=prevId,proto3" json:"prevId,omitempty"`
	Identity  []byte `protobuf:"bytes,2,opt,name=identity,proto3" json:"identity,omitempty"`
	Data      []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Timestamp int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *AclRecord) Reset()         { *m = AclRecord{} }
func (m *AclRecord) String() string { return proto.CompactTextString(m) }
func (*AclRecord) ProtoMessage()    {}
func (*AclRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{2}
}
func (m *AclRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclRecord.Merge(m, src)
}
func (m *AclRecord) XXX_Size() int {
	return m.Size()
}
func (m *AclRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AclRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AclRecord proto.InternalMessageInfo

func (m *AclRecord) GetPrevId() string {
	if m != nil {
		return m.PrevId
	}
	return ""
}

func (m *AclRecord) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AclRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// AclRoot is a root of access control list
type AclRoot struct {
	Identity          []byte `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	MasterKey         []byte `protobuf:"bytes,2,opt,name=masterKey,proto3" json:"masterKey,omitempty"`
	SpaceId           string `protobuf:"bytes,3,opt,name=spaceId,proto3" json:"spaceId,omitempty"`
	EncryptedReadKey  []byte `protobuf:"bytes,4,opt,name=encryptedReadKey,proto3" json:"encryptedReadKey,omitempty"`
	Timestamp         int64  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	IdentitySignature []byte `protobuf:"bytes,6,opt,name=identitySignature,proto3" json:"identitySignature,omitempty"`
}

func (m *AclRoot) Reset()         { *m = AclRoot{} }
func (m *AclRoot) String() string { return proto.CompactTextString(m) }
func (*AclRoot) ProtoMessage()    {}
func (*AclRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{3}
}
func (m *AclRoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclRoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclRoot.Merge(m, src)
}
func (m *AclRoot) XXX_Size() int {
	return m.Size()
}
func (m *AclRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_AclRoot.DiscardUnknown(m)
}

var xxx_messageInfo_AclRoot proto.InternalMessageInfo

func (m *AclRoot) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclRoot) GetMasterKey() []byte {
	if m != nil {
		return m.MasterKey
	}
	return nil
}

func (m *AclRoot) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

func (m *AclRoot) GetEncryptedReadKey() []byte {
	if m != nil {
		return m.EncryptedReadKey
	}
	return nil
}

func (m *AclRoot) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AclRoot) GetIdentitySignature() []byte {
	if m != nil {
		return m.IdentitySignature
	}
	return nil
}

// AclAccountInvite contains the public invite key, the private part of which is sent to the user directly
type AclAccountInvite struct {
	InviteKey []byte `protobuf:"bytes,1,opt,name=inviteKey,proto3" json:"inviteKey,omitempty"`
}

func (m *AclAccountInvite) Reset()         { *m = AclAccountInvite{} }
func (m *AclAccountInvite) String() string { return proto.CompactTextString(m) }
func (*AclAccountInvite) ProtoMessage()    {}
func (*AclAccountInvite) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{4}
}
func (m *AclAccountInvite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountInvite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountInvite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountInvite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountInvite.Merge(m, src)
}
func (m *AclAccountInvite) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountInvite) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountInvite.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountInvite proto.InternalMessageInfo

func (m *AclAccountInvite) GetInviteKey() []byte {
	if m != nil {
		return m.InviteKey
	}
	return nil
}

// AclAccountRequestJoin contains the reference to the invite record and the data of the person who wants to join, confirmed by the private invite key
type AclAccountRequestJoin struct {
	InviteIdentity          []byte `protobuf:"bytes,1,opt,name=inviteIdentity,proto3" json:"inviteIdentity,omitempty"`
	InviteRecordId          string `protobuf:"bytes,2,opt,name=inviteRecordId,proto3" json:"inviteRecordId,omitempty"`
	InviteIdentitySignature []byte `protobuf:"bytes,3,opt,name=inviteIdentitySignature,proto3" json:"inviteIdentitySignature,omitempty"`
	Metadata                []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *AclAccountRequestJoin) Reset()         { *m = AclAccountRequestJoin{} }
func (m *AclAccountRequestJoin) String() string { return proto.CompactTextString(m) }
func (*AclAccountRequestJoin) ProtoMessage()    {}
func (*AclAccountRequestJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{5}
}
func (m *AclAccountRequestJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountRequestJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountRequestJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountRequestJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountRequestJoin.Merge(m, src)
}
func (m *AclAccountRequestJoin) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountRequestJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountRequestJoin.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountRequestJoin proto.InternalMessageInfo

func (m *AclAccountRequestJoin) GetInviteIdentity() []byte {
	if m != nil {
		return m.InviteIdentity
	}
	return nil
}

func (m *AclAccountRequestJoin) GetInviteRecordId() string {
	if m != nil {
		return m.InviteRecordId
	}
	return ""
}

func (m *AclAccountRequestJoin) GetInviteIdentitySignature() []byte {
	if m != nil {
		return m.InviteIdentitySignature
	}
	return nil
}

func (m *AclAccountRequestJoin) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// AclAccountRequestAccept contains the reference to join record and all read keys, encrypted with the identity of the requestor
type AclAccountRequestAccept struct {
	Identity          []byte             `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	RequestRecordId   string             `protobuf:"bytes,2,opt,name=requestRecordId,proto3" json:"requestRecordId,omitempty"`
	EncryptedReadKeys []byte             `protobuf:"bytes,3,opt,name=encryptedReadKeys,proto3" json:"encryptedReadKeys,omitempty"`
	Permissions       AclUserPermissions `protobuf:"varint,4,opt,name=permissions,proto3,enum=aclrecord.AclUserPermissions" json:"permissions,omitempty"`
}

func (m *AclAccountRequestAccept) Reset()         { *m = AclAccountRequestAccept{} }
func (m *AclAccountRequestAccept) String() string { return proto.CompactTextString(m) }
func (*AclAccountRequestAccept) ProtoMessage()    {}
func (*AclAccountRequestAccept) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{6}
}
func (m *AclAccountRequestAccept) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountRequestAccept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountRequestAccept.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountRequestAccept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountRequestAccept.Merge(m, src)
}
func (m *AclAccountRequestAccept) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountRequestAccept) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountRequestAccept.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountRequestAccept proto.InternalMessageInfo

func (m *AclAccountRequestAccept) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclAccountRequestAccept) GetRequestRecordId() string {
	if m != nil {
		return m.RequestRecordId
	}
	return ""
}

func (m *AclAccountRequestAccept) GetEncryptedReadKeys() []byte {
	if m != nil {
		return m.EncryptedReadKeys
	}
	return nil
}

func (m *AclAccountRequestAccept) GetPermissions() AclUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return AclUserPermissions_None
}

// AclAccountRequestDecline contains the reference to join record
type AclAccountRequestDecline struct {
	RequestRecordId string `protobuf:"bytes,1,opt,name=requestRecordId,proto3" json:"requestRecordId,omitempty"`
}

func (m *AclAccountRequestDecline) Reset()         { *m = AclAccountRequestDecline{} }
func (m *AclAccountRequestDecline) String() string { return proto.CompactTextString(m) }
func (*AclAccountRequestDecline) ProtoMessage()    {}
func (*AclAccountRequestDecline) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{7}
}
func (m *AclAccountRequestDecline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountRequestDecline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountRequestDecline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountRequestDecline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountRequestDecline.Merge(m, src)
}
func (m *AclAccountRequestDecline) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountRequestDecline) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountRequestDecline.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountRequestDecline proto.InternalMessageInfo

func (m *AclAccountRequestDecline) GetRequestRecordId() string {
	if m != nil {
		return m.RequestRecordId
	}
	return ""
}

// AclAccountInviteRevoke revokes the invite record
type AclAccountInviteRevoke struct {
	InviteRecordId string `protobuf:"bytes,1,opt,name=inviteRecordId,proto3" json:"inviteRecordId,omitempty"`
}

func (m *AclAccountInviteRevoke) Reset()         { *m = AclAccountInviteRevoke{} }
func (m *AclAccountInviteRevoke) String() string { return proto.CompactTextString(m) }
func (*AclAccountInviteRevoke) ProtoMessage()    {}
func (*AclAccountInviteRevoke) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{8}
}
func (m *AclAccountInviteRevoke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountInviteRevoke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountInviteRevoke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountInviteRevoke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountInviteRevoke.Merge(m, src)
}
func (m *AclAccountInviteRevoke) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountInviteRevoke) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountInviteRevoke.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountInviteRevoke proto.InternalMessageInfo

func (m *AclAccountInviteRevoke) GetInviteRecordId() string {
	if m != nil {
		return m.InviteRecordId
	}
	return ""
}

// AclReadKeys are all read keys in Acl
type AclReadKeys struct {
	ReadKeys map[string][]byte `protobuf:"bytes,1,rep,name=readKeys,proto3" json:"readKeys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AclReadKeys) Reset()         { *m = AclReadKeys{} }
func (m *AclReadKeys) String() string { return proto.CompactTextString(m) }
func (*AclReadKeys) ProtoMessage()    {}
func (*AclReadKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{9}
}
func (m *AclReadKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclReadKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclReadKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclReadKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclReadKeys.Merge(m, src)
}
func (m *AclReadKeys) XXX_Size() int {
	return m.Size()
}
func (m *AclReadKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_AclReadKeys.DiscardUnknown(m)
}

var xxx_messageInfo_AclReadKeys proto.InternalMessageInfo

func (m *AclReadKeys) GetReadKeys() map[string][]byte {
	if m != nil {
		return m.ReadKeys
	}
	return nil
}

// AclEncryptedReadKeys are new key for specific identity
type AclEncryptedReadKey struct {
	Identity         []byte `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	EncryptedReadKey []byte `protobuf:"bytes,2,opt,name=encryptedReadKey,proto3" json:"encryptedReadKey,omitempty"`
}

func (m *AclEncryptedReadKey) Reset()         { *m = AclEncryptedReadKey{} }
func (m *AclEncryptedReadKey) String() string { return proto.CompactTextString(m) }
func (*AclEncryptedReadKey) ProtoMessage()    {}
func (*AclEncryptedReadKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{10}
}
func (m *AclEncryptedReadKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclEncryptedReadKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclEncryptedReadKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclEncryptedReadKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclEncryptedReadKey.Merge(m, src)
}
func (m *AclEncryptedReadKey) XXX_Size() int {
	return m.Size()
}
func (m *AclEncryptedReadKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AclEncryptedReadKey.DiscardUnknown(m)
}

var xxx_messageInfo_AclEncryptedReadKey proto.InternalMessageInfo

func (m *AclEncryptedReadKey) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclEncryptedReadKey) GetEncryptedReadKey() []byte {
	if m != nil {
		return m.EncryptedReadKey
	}
	return nil
}

// AclAccountPermissionChange changes permissions of specific account
type AclAccountPermissionChange struct {
	Identity    []byte             `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Permissions AclUserPermissions `protobuf:"varint,2,opt,name=permissions,proto3,enum=aclrecord.AclUserPermissions" json:"permissions,omitempty"`
}

func (m *AclAccountPermissionChange) Reset()         { *m = AclAccountPermissionChange{} }
func (m *AclAccountPermissionChange) String() string { return proto.CompactTextString(m) }
func (*AclAccountPermissionChange) ProtoMessage()    {}
func (*AclAccountPermissionChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{11}
}
func (m *AclAccountPermissionChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountPermissionChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountPermissionChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountPermissionChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountPermissionChange.Merge(m, src)
}
func (m *AclAccountPermissionChange) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountPermissionChange) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountPermissionChange.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountPermissionChange proto.InternalMessageInfo

func (m *AclAccountPermissionChange) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclAccountPermissionChange) GetPermissions() AclUserPermissions {
	if m != nil {
		return m.Permissions
	}
	return AclUserPermissions_None
}

// AclReadKeyChange changes the key for a space
type AclReadKeyChange struct {
	AccountKeys []*AclEncryptedReadKey `protobuf:"bytes,1,rep,name=accountKeys,proto3" json:"accountKeys,omitempty"`
}

func (m *AclReadKeyChange) Reset()         { *m = AclReadKeyChange{} }
func (m *AclReadKeyChange) String() string { return proto.CompactTextString(m) }
func (*AclReadKeyChange) ProtoMessage()    {}
func (*AclReadKeyChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{12}
}
func (m *AclReadKeyChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclReadKeyChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclReadKeyChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclReadKeyChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclReadKeyChange.Merge(m, src)
}
func (m *AclReadKeyChange) XXX_Size() int {
	return m.Size()
}
func (m *AclReadKeyChange) XXX_DiscardUnknown() {
	xxx_messageInfo_AclReadKeyChange.DiscardUnknown(m)
}

var xxx_messageInfo_AclReadKeyChange proto.InternalMessageInfo

func (m *AclReadKeyChange) GetAccountKeys() []*AclEncryptedReadKey {
	if m != nil {
		return m.AccountKeys
	}
	return nil
}

// AclAccountRemove removes an account and changes read key for space
type AclAccountRemove struct {
	Identity    []byte                 `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	AccountKeys []*AclEncryptedReadKey `protobuf:"bytes,2,rep,name=accountKeys,proto3" json:"accountKeys,omitempty"`
}

func (m *AclAccountRemove) Reset()         { *m = AclAccountRemove{} }
func (m *AclAccountRemove) String() string { return proto.CompactTextString(m) }
func (*AclAccountRemove) ProtoMessage()    {}
func (*AclAccountRemove) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{13}
}
func (m *AclAccountRemove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAccountRemove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAccountRemove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAccountRemove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAccountRemove.Merge(m, src)
}
func (m *AclAccountRemove) XXX_Size() int {
	return m.Size()
}
func (m *AclAccountRemove) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAccountRemove.DiscardUnknown(m)
}

var xxx_messageInfo_AclAccountRemove proto.InternalMessageInfo

func (m *AclAccountRemove) GetIdentity() []byte {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *AclAccountRemove) GetAccountKeys() []*AclEncryptedReadKey {
	if m != nil {
		return m.AccountKeys
	}
	return nil
}

// AclContentValue contains possible values for Acl
type AclContentValue struct {
	// Types that are valid to be assigned to Value:
	//
	//	*AclContentValue_Invite
	//	*AclContentValue_InviteRevoke
	//	*AclContentValue_RequestJoin
	//	*AclContentValue_RequestAccept
	//	*AclContentValue_PermissionChange
	//	*AclContentValue_AccountRemove
	//	*AclContentValue_ReadKeyChange
	//	*AclContentValue_RequestDecline
	Value isAclContentValue_Value `protobuf_oneof:"value"`
}

func (m *AclContentValue) Reset()         { *m = AclContentValue{} }
func (m *AclContentValue) String() string { return proto.CompactTextString(m) }
func (*AclContentValue) ProtoMessage()    {}
func (*AclContentValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{14}
}
func (m *AclContentValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclContentValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclContentValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclContentValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclContentValue.Merge(m, src)
}
func (m *AclContentValue) XXX_Size() int {
	return m.Size()
}
func (m *AclContentValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AclContentValue.DiscardUnknown(m)
}

var xxx_messageInfo_AclContentValue proto.InternalMessageInfo

type isAclContentValue_Value interface {
	isAclContentValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclContentValue_Invite struct {
	Invite *AclAccountInvite `protobuf:"bytes,1,opt,name=invite,proto3,oneof" json:"invite,omitempty"`
}
type AclContentValue_InviteRevoke struct {
	InviteRevoke *AclAccountInviteRevoke `protobuf:"bytes,2,opt,name=inviteRevoke,proto3,oneof" json:"inviteRevoke,omitempty"`
}
type AclContentValue_RequestJoin struct {
	RequestJoin *AclAccountRequestJoin `protobuf:"bytes,3,opt,name=requestJoin,proto3,oneof" json:"requestJoin,omitempty"`
}
type AclContentValue_RequestAccept struct {
	RequestAccept *AclAccountRequestAccept `protobuf:"bytes,4,opt,name=requestAccept,proto3,oneof" json:"requestAccept,omitempty"`
}
type AclContentValue_PermissionChange struct {
	PermissionChange *AclAccountPermissionChange `protobuf:"bytes,5,opt,name=permissionChange,proto3,oneof" json:"permissionChange,omitempty"`
}
type AclContentValue_AccountRemove struct {
	AccountRemove *AclAccountRemove `protobuf:"bytes,6,opt,name=accountRemove,proto3,oneof" json:"accountRemove,omitempty"`
}
type AclContentValue_ReadKeyChange struct {
	ReadKeyChange *AclReadKeyChange `protobuf:"bytes,7,opt,name=readKeyChange,proto3,oneof" json:"readKeyChange,omitempty"`
}
type AclContentValue_RequestDecline struct {
	RequestDecline *AclAccountRequestDecline `protobuf:"bytes,8,opt,name=requestDecline,proto3,oneof" json:"requestDecline,omitempty"`
}

func (*AclContentValue_Invite) isAclContentValue_Value()           {}
func (*AclContentValue_InviteRevoke) isAclContentValue_Value()     {}
func (*AclContentValue_RequestJoin) isAclContentValue_Value()      {}
func (*AclContentValue_RequestAccept) isAclContentValue_Value()    {}
func (*AclContentValue_PermissionChange) isAclContentValue_Value() {}
func (*AclContentValue_AccountRemove) isAclContentValue_Value()    {}
func (*AclContentValue_ReadKeyChange) isAclContentValue_Value()    {}
func (*AclContentValue_RequestDecline) isAclContentValue_Value()   {}

func (m *AclContentValue) GetValue() isAclContentValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AclContentValue) GetInvite() *AclAccountInvite {
	if x, ok := m.GetValue().(*AclContentValue_Invite); ok {
		return x.Invite
	}
	return nil
}

func (m *AclContentValue) GetInviteRevoke() *AclAccountInviteRevoke {
	if x, ok := m.GetValue().(*AclContentValue_InviteRevoke); ok {
		return x.InviteRevoke
	}
	return nil
}

func (m *AclContentValue) GetRequestJoin() *AclAccountRequestJoin {
	if x, ok := m.GetValue().(*AclContentValue_RequestJoin); ok {
		return x.RequestJoin
	}
	return nil
}

func (m *AclContentValue) GetRequestAccept() *AclAccountRequestAccept {
	if x, ok := m.GetValue().(*AclContentValue_RequestAccept); ok {
		return x.RequestAccept
	}
	return nil
}

func (m *AclContentValue) GetPermissionChange() *AclAccountPermissionChange {
	if x, ok := m.GetValue().(*AclContentValue_PermissionChange); ok {
		return x.PermissionChange
	}
	return nil
}

func (m *AclContentValue) GetAccountRemove() *AclAccountRemove {
	if x, ok := m.GetValue().(*AclContentValue_AccountRemove); ok {
		return x.AccountRemove
	}
	return nil
}

func (m *AclContentValue) GetReadKeyChange() *AclReadKeyChange {
	if x, ok := m.GetValue().(*AclContentValue_ReadKeyChange); ok {
		return x.ReadKeyChange
	}
	return nil
}

func (m *AclContentValue) GetRequestDecline() *AclAccountRequestDecline {
	if x, ok := m.GetValue().(*AclContentValue_RequestDecline); ok {
		return x.RequestDecline
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AclContentValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AclContentValue_Invite)(nil),
		(*AclContentValue_InviteRevoke)(nil),
		(*AclContentValue_RequestJoin)(nil),
		(*AclContentValue_RequestAccept)(nil),
		(*AclContentValue_PermissionChange)(nil),
		(*AclContentValue_AccountRemove)(nil),
		(*AclContentValue_ReadKeyChange)(nil),
		(*AclContentValue_RequestDecline)(nil),
	}
}

// AclData contains different acl content
type AclData struct {
	AclContent []*AclContentValue `protobuf:"bytes,1,rep,name=aclContent,proto3" json:"aclContent,omitempty"`
}

func (m *AclData) Reset()         { *m = AclData{} }
func (m *AclData) String() string { return proto.CompactTextString(m) }
func (*AclData) ProtoMessage()    {}
func (*AclData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{15}
}
func (m *AclData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclData.Merge(m, src)
}
func (m *AclData) XXX_Size() int {
	return m.Size()
}
func (m *AclData) XXX_DiscardUnknown() {
	xxx_messageInfo_AclData.DiscardUnknown(m)
}

var xxx_messageInfo_AclData proto.InternalMessageInfo

func (m *AclData) GetAclContent() []*AclContentValue {
	if m != nil {
		return m.AclContent
	}
	return nil
}

type AclSyncMessage struct {
	Content *AclSyncContentValue `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *AclSyncMessage) Reset()         { *m = AclSyncMessage{} }
func (m *AclSyncMessage) String() string { return proto.CompactTextString(m) }
func (*AclSyncMessage) ProtoMessage()    {}
func (*AclSyncMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{16}
}
func (m *AclSyncMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclSyncMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclSyncMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclSyncMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclSyncMessage.Merge(m, src)
}
func (m *AclSyncMessage) XXX_Size() int {
	return m.Size()
}
func (m *AclSyncMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_AclSyncMessage.DiscardUnknown(m)
}

var xxx_messageInfo_AclSyncMessage proto.InternalMessageInfo

func (m *AclSyncMessage) GetContent() *AclSyncContentValue {
	if m != nil {
		return m.Content
	}
	return nil
}

// AclSyncContentValue provides different types for acl sync
type AclSyncContentValue struct {
	// Types that are valid to be assigned to Value:
	//
	//	*AclSyncContentValue_AddRecords
	Value isAclSyncContentValue_Value `protobuf_oneof:"value"`
}

func (m *AclSyncContentValue) Reset()         { *m = AclSyncContentValue{} }
func (m *AclSyncContentValue) String() string { return proto.CompactTextString(m) }
func (*AclSyncContentValue) ProtoMessage()    {}
func (*AclSyncContentValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{17}
}
func (m *AclSyncContentValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclSyncContentValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclSyncContentValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclSyncContentValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclSyncContentValue.Merge(m, src)
}
func (m *AclSyncContentValue) XXX_Size() int {
	return m.Size()
}
func (m *AclSyncContentValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AclSyncContentValue.DiscardUnknown(m)
}

var xxx_messageInfo_AclSyncContentValue proto.InternalMessageInfo

type isAclSyncContentValue_Value interface {
	isAclSyncContentValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AclSyncContentValue_AddRecords struct {
	AddRecords *AclAddRecords `protobuf:"bytes,1,opt,name=addRecords,proto3,oneof" json:"addRecords,omitempty"`
}

func (*AclSyncContentValue_AddRecords) isAclSyncContentValue_Value() {}

func (m *AclSyncContentValue) GetValue() isAclSyncContentValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AclSyncContentValue) GetAddRecords() *AclAddRecords {
	if x, ok := m.GetValue().(*AclSyncContentValue_AddRecords); ok {
		return x.AddRecords
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AclSyncContentValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AclSyncContentValue_AddRecords)(nil),
	}
}

type AclAddRecords struct {
	Records []*RawAclRecordWithId `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
}

func (m *AclAddRecords) Reset()         { *m = AclAddRecords{} }
func (m *AclAddRecords) String() string { return proto.CompactTextString(m) }
func (*AclAddRecords) ProtoMessage()    {}
func (*AclAddRecords) Descriptor() ([]byte, []int) {
	return fileDescriptor_c8e9f754f34e929b, []int{18}
}
func (m *AclAddRecords) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AclAddRecords) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AclAddRecords.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AclAddRecords) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AclAddRecords.Merge(m, src)
}
func (m *AclAddRecords) XXX_Size() int {
	return m.Size()
}
func (m *AclAddRecords) XXX_DiscardUnknown() {
	xxx_messageInfo_AclAddRecords.DiscardUnknown(m)
}

var xxx_messageInfo_AclAddRecords proto.InternalMessageInfo

func (m *AclAddRecords) GetRecords() []*RawAclRecordWithId {
	if m != nil {
		return m.Records
	}
	return nil
}

func init() {
	proto.RegisterEnum("aclrecord.AclUserPermissions", AclUserPermissions_name, AclUserPermissions_value)
	proto.RegisterType((*RawAclRecord)(nil), "aclrecord.RawAclRecord")
	proto.RegisterType((*RawAclRecordWithId)(nil), "aclrecord.RawAclRecordWithId")
	proto.RegisterType((*AclRecord)(nil), "aclrecord.AclRecord")
	proto.RegisterType((*AclRoot)(nil), "aclrecord.AclRoot")
	proto.RegisterType((*AclAccountInvite)(nil), "aclrecord.AclAccountInvite")
	proto.RegisterType((*AclAccountRequestJoin)(nil), "aclrecord.AclAccountRequestJoin")
	proto.RegisterType((*AclAccountRequestAccept)(nil), "aclrecord.AclAccountRequestAccept")
	proto.RegisterType((*AclAccountRequestDecline)(nil), "aclrecord.AclAccountRequestDecline")
	proto.RegisterType((*AclAccountInviteRevoke)(nil), "aclrecord.AclAccountInviteRevoke")
	proto.RegisterType((*AclReadKeys)(nil), "aclrecord.AclReadKeys")
	proto.RegisterMapType((map[string][]byte)(nil), "aclrecord.AclReadKeys.ReadKeysEntry")
	proto.RegisterType((*AclEncryptedReadKey)(nil), "aclrecord.AclEncryptedReadKey")
	proto.RegisterType((*AclAccountPermissionChange)(nil), "aclrecord.AclAccountPermissionChange")
	proto.RegisterType((*AclReadKeyChange)(nil), "aclrecord.AclReadKeyChange")
	proto.RegisterType((*AclAccountRemove)(nil), "aclrecord.AclAccountRemove")
	proto.RegisterType((*AclContentValue)(nil), "aclrecord.AclContentValue")
	proto.RegisterType((*AclData)(nil), "aclrecord.AclData")
	proto.RegisterType((*AclSyncMessage)(nil), "aclrecord.AclSyncMessage")
	proto.RegisterType((*AclSyncContentValue)(nil), "aclrecord.AclSyncContentValue")
	proto.RegisterType((*AclAddRecords)(nil), "aclrecord.AclAddRecords")
}

func init() {
	proto.RegisterFile("commonspace/object/acl/aclrecordproto/protos/aclrecord.proto", fileDescriptor_c8e9f754f34e929b)
}

var fileDescriptor_c8e9f754f34e929b = []byte{
	// 1005 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0xde, 0xb5, 0x1d, 0x3b, 0x3e, 0x9b, 0xb8, 0xfe, 0xcd, 0x0f, 0x5a, 0x2b, 0x14, 0x2b, 0x2c,
	0x14, 0x45, 0x15, 0x4a, 0x90, 0x11, 0x22, 0x2a, 0x88, 0x66, 0x9b, 0x44, 0xd8, 0x81, 0x02, 0x9a,
	0x00, 0x95, 0x2a, 0x71, 0x31, 0x9d, 0x1d, 0xa5, 0x4b, 0xf7, 0x5f, 0x67, 0x27, 0xae, 0xfc, 0x0e,
	0x5c, 0xf0, 0x08, 0xbc, 0x08, 0xf7, 0x5c, 0xa1, 0xde, 0x20, 0x21, 0xae, 0x50, 0xf2, 0x22, 0x68,
	0x66, 0xf6, 0xff, 0x6e, 0x2d, 0x7a, 0xd1, 0x66, 0xe6, 0xcc, 0x39, 0xdf, 0x7c, 0xe7, 0x7c, 0x67,
	0xce, 0x1a, 0x3e, 0xa3, 0x51, 0x10, 0x44, 0x61, 0x12, 0x13, 0xca, 0x0e, 0xa2, 0x27, 0x3f, 0x31,
	0x2a, 0x0e, 0x08, 0xf5, 0xe5, 0x3f, 0xce, 0x68, 0xc4, 0xdd, 0x98, 0x47, 0x22, 0x3a, 0x50, 0xff,
	0x27, 0x85, 0x75, 0x5f, 0x19, 0xd0, 0x30, 0x37, 0xd8, 0xbf, 0x9a, 0xb0, 0x85, 0xc9, 0x0b, 0x87,
	0xfa, 0x58, 0x19, 0xd0, 0x04, 0x06, 0x31, 0x59, 0xf9, 0x11, 0x71, 0x27, 0xe6, 0xae, 0xb9, 0xb7,
	0x85, 0xb3, 0x2d, 0xba, 0x0d, 0xc3, 0xc4, 0xbb, 0x08, 0x89, 0xb8, 0xe4, 0x6c, 0xd2, 0x51, 0x67,
	0x85, 0x01, 0xdd, 0x85, 0x31, 0xa1, 0x94, 0xc5, 0x22, 0xe2, 0x0b, 0x97, 0x85, 0xc2, 0x13, 0xab,
	0x49, 0x57, 0x39, 0x35, 0xec, 0xe8, 0x03, 0xf8, 0x5f, 0x66, 0x3b, 0xcf, 0x11, 0x7b, 0xca, 0xb9,
	0x79, 0x60, 0x7f, 0x0e, 0xa8, 0xcc, 0xf0, 0x91, 0x27, 0x9e, 0x2e, 0xd6, 0xf1, 0x1c, 0x41, 0xc7,
	0x73, 0x15, 0xc1, 0x21, 0xee, 0x78, 0xae, 0xfd, 0x1c, 0x86, 0x45, 0x7a, 0x37, 0xa1, 0x1f, 0x73,
	0xb6, 0x5c, 0xe8, 0xa8, 0x21, 0x4e, 0x77, 0x68, 0x07, 0x36, 0xbd, 0x8c, 0xb6, 0xce, 0x2d, 0xdf,
	0x23, 0x04, 0x3d, 0x97, 0x08, 0x92, 0xa6, 0xa3, 0xd6, 0xb2, 0x18, 0xc2, 0x0b, 0x58, 0x22, 0x48,
	0x10, 0x2b, 0xea, 0x5d, 0x5c, 0x18, 0xec, 0x3f, 0x4d, 0x18, 0xc8, 0x3b, 0xa3, 0x48, 0x54, 0x90,
	0xcd, 0x1a, 0xf2, 0x6d, 0x18, 0x06, 0x24, 0x11, 0x8c, 0x7f, 0xc9, 0xb2, 0x6b, 0x0b, 0x83, 0x4c,
	0x51, 0x09, 0xbc, 0x70, 0xd5, 0xd5, 0x43, 0x9c, 0x6d, 0x65, 0xb1, 0x59, 0x48, 0xf9, 0x2a, 0x16,
	0xcc, 0xc5, 0x8c, 0xb8, 0x32, 0x5c, 0xd7, 0xaf, 0x61, 0xaf, 0x32, 0xdd, 0xa8, 0x31, 0x95, 0x52,
	0x64, 0x6c, 0x0a, 0x29, 0xfa, 0x5a, 0x8a, 0xc6, 0x81, 0xfd, 0x21, 0x8c, 0x1d, 0xea, 0x3b, 0x94,
	0x46, 0x97, 0xa1, 0x58, 0x84, 0x4b, 0x4f, 0x30, 0x89, 0xef, 0xa9, 0x95, 0x24, 0xa1, 0x13, 0x2c,
	0x0c, 0xf6, 0x6f, 0x26, 0xbc, 0x59, 0x84, 0x60, 0xf6, 0xfc, 0x92, 0x25, 0xe2, 0x2c, 0xf2, 0x42,
	0xf4, 0x3e, 0x8c, 0xb4, 0xdb, 0xa2, 0x5a, 0x9d, 0x9a, 0xb5, 0xf0, 0xd3, 0x0a, 0x2e, 0x32, 0x69,
	0x6b, 0x56, 0x74, 0x08, 0xb7, 0xaa, 0x91, 0x45, 0x3e, 0x5a, 0xb8, 0x57, 0x1d, 0x4b, 0x85, 0x02,
	0x26, 0x88, 0xd2, 0x58, 0x57, 0x31, 0xdf, 0xdb, 0x7f, 0x98, 0x70, 0xab, 0xc1, 0xdf, 0x51, 0x3d,
	0xba, 0x56, 0xd9, 0x3d, 0xb8, 0xc1, 0xb5, 0x73, 0x8d, 0x76, 0xdd, 0x2c, 0x15, 0xa8, 0x6b, 0x96,
	0xa4, 0x8c, 0x9b, 0x07, 0xe8, 0x3e, 0x58, 0x31, 0xe3, 0x81, 0x97, 0x24, 0x5e, 0x14, 0x26, 0x8a,
	0xee, 0x68, 0xf6, 0xf6, 0x7e, 0xf1, 0xc2, 0x1d, 0xea, 0x7f, 0x9f, 0x30, 0xfe, 0x6d, 0xe1, 0x84,
	0xcb, 0x11, 0xf6, 0x09, 0x4c, 0x1a, 0xf9, 0x9c, 0x30, 0xea, 0x7b, 0x21, 0x6b, 0x23, 0x6d, 0xb6,
	0x92, 0xb6, 0x8f, 0xe0, 0x66, 0xbd, 0x11, 0x30, 0x5b, 0x46, 0xcf, 0x58, 0x8b, 0x5c, 0x66, 0x9b,
	0x5c, 0xf6, 0xcf, 0x26, 0x58, 0xea, 0x59, 0xa6, 0x89, 0x1d, 0xc1, 0x26, 0xcf, 0xb2, 0x37, 0x77,
	0xbb, 0x7b, 0xd6, 0xec, 0xbd, 0x6a, 0x56, 0x99, 0xe7, 0x7e, 0xb6, 0x38, 0x0d, 0x05, 0x5f, 0xe1,
	0x3c, 0x6a, 0xe7, 0x53, 0xd8, 0xae, 0x1c, 0xa1, 0x31, 0x74, 0x9f, 0xa5, 0x3d, 0x39, 0xc4, 0x72,
	0x89, 0xde, 0x80, 0x8d, 0x25, 0xf1, 0x2f, 0xb3, 0xf1, 0xa5, 0x37, 0xf7, 0x3a, 0x87, 0xa6, 0xfd,
	0x23, 0xfc, 0xdf, 0xa1, 0xfe, 0x69, 0xfd, 0xf1, 0xac, 0x93, 0xb8, 0xed, 0x11, 0x76, 0xda, 0x1f,
	0xa1, 0xbd, 0x82, 0x9d, 0xa2, 0x5e, 0x85, 0x36, 0xc7, 0x4f, 0x49, 0x78, 0xc1, 0xd6, 0xde, 0x52,
	0x13, 0xbc, 0xf3, 0xda, 0x82, 0x7f, 0xa7, 0xde, 0x6c, 0x4a, 0x24, 0xbd, 0xf0, 0x08, 0x2c, 0xa2,
	0xb9, 0x94, 0xea, 0x3d, 0xad, 0x82, 0xd6, 0x6b, 0x81, 0xcb, 0x21, 0x76, 0x5c, 0x9e, 0x04, 0x98,
	0x05, 0xd1, 0x72, 0x7d, 0x1a, 0xb5, 0x1b, 0x3b, 0xaf, 0x7f, 0xe3, 0xdf, 0x3d, 0xb8, 0xe1, 0x50,
	0xff, 0x38, 0x0a, 0x05, 0x0b, 0xc5, 0x0f, 0x52, 0x39, 0xf4, 0x31, 0xf4, 0x75, 0x5b, 0xa9, 0xfb,
	0xac, 0xd9, 0x5b, 0x55, 0xc0, 0x4a, 0x7f, 0xce, 0x0d, 0x9c, 0x3a, 0xa3, 0x2f, 0x60, 0xcb, 0x2b,
	0xf5, 0xac, 0x2a, 0xaa, 0x35, 0x7b, 0x67, 0x4d, 0xb0, 0x76, 0x9c, 0x1b, 0xb8, 0x12, 0x88, 0x4e,
	0xc0, 0xe2, 0xc5, 0x48, 0x53, 0xaf, 0xd6, 0x9a, 0xed, 0xb6, 0xe2, 0x94, 0x46, 0xdf, 0xdc, 0xc0,
	0xe5, 0x30, 0x74, 0x06, 0xdb, 0xbc, 0x3c, 0x58, 0xd4, 0xab, 0xb6, 0x66, 0xf6, 0x3a, 0x1c, 0xed,
	0x39, 0x37, 0x70, 0x35, 0x14, 0x9d, 0xc3, 0x38, 0xae, 0xb5, 0x97, 0x1a, 0xfa, 0xd6, 0xec, 0x4e,
	0x2b, 0x5c, 0xbd, 0x17, 0xe7, 0x06, 0x6e, 0x00, 0xa0, 0x63, 0xd8, 0x26, 0x65, 0xa5, 0xd5, 0x07,
	0xe2, 0x55, 0xd5, 0xd6, 0x2e, 0x92, 0x59, 0x25, 0x46, 0x82, 0xf0, 0x72, 0x13, 0x4e, 0x06, 0x6d,
	0x20, 0x95, 0x3e, 0xd5, 0xe9, 0x95, 0x1b, 0xf7, 0x21, 0x8c, 0x78, 0x65, 0x66, 0x4d, 0x36, 0x15,
	0xca, 0xbb, 0xeb, 0x6a, 0x95, 0xba, 0xce, 0x0d, 0x5c, 0x0b, 0x7e, 0x30, 0x48, 0xe7, 0x81, 0x7d,
	0xaa, 0xbe, 0xd7, 0x27, 0xf2, 0xcb, 0x7e, 0x0f, 0x80, 0xe4, 0x6d, 0x96, 0x3e, 0x8d, 0x9d, 0x2a,
	0x7c, 0xb9, 0x07, 0x71, 0xc9, 0xdb, 0x3e, 0x83, 0x91, 0x43, 0xfd, 0xf3, 0x55, 0x48, 0x1f, 0xb2,
	0x24, 0x21, 0x17, 0x0c, 0x1d, 0xc2, 0x80, 0xe6, 0x50, 0x66, 0xb3, 0xe7, 0xa5, 0x6f, 0x05, 0x2e,
	0x73, 0xb7, 0x1f, 0xab, 0x89, 0x54, 0x3f, 0x57, 0xf4, 0x5c, 0x57, 0x8f, 0xd1, 0x24, 0xc5, 0x9c,
	0xd4, 0xb2, 0xcf, 0xcf, 0xe7, 0x06, 0x2e, 0x79, 0x17, 0xe9, 0xce, 0x61, 0xbb, 0xe2, 0x87, 0x3e,
	0x81, 0x01, 0xcf, 0x21, 0x65, 0xc6, 0xe5, 0x09, 0xd3, 0xfc, 0xf5, 0x85, 0x33, 0xef, 0xbb, 0x5f,
	0x01, 0x6a, 0x0e, 0x20, 0xb4, 0x09, 0xbd, 0xaf, 0xa3, 0x90, 0x8d, 0x0d, 0x34, 0x84, 0x8d, 0x6f,
	0x5e, 0x84, 0x8c, 0x8f, 0x4d, 0xb9, 0x74, 0xdc, 0xc0, 0x0b, 0xc7, 0x1d, 0x04, 0xd0, 0x7f, 0xc4,
	0x3d, 0xc1, 0xf8, 0xb8, 0x2b, 0xd7, 0x52, 0x74, 0xc6, 0xc7, 0xbd, 0x07, 0xf7, 0x7f, 0xbf, 0x9a,
	0x9a, 0x2f, 0xaf, 0xa6, 0xe6, 0x3f, 0x57, 0x53, 0xf3, 0x97, 0xeb, 0xa9, 0xf1, 0xf2, 0x7a, 0x6a,
	0xfc, 0x75, 0x3d, 0x35, 0x1e, 0xdf, 0xf9, 0x4f, 0x3f, 0x78, 0x9f, 0xf4, 0xd5, 0x9f, 0x8f, 0xfe,
	0x0d, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x8e, 0x57, 0x42, 0x20, 0x0b, 0x00, 0x00,
}

func (m *RawAclRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawAclRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawAclRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptorSignature) > 0 {
		i -= len(m.AcceptorSignature)
		copy(dAtA[i:], m.AcceptorSignature)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.AcceptorSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AcceptorIdentity) > 0 {
		i -= len(m.AcceptorIdentity)
		copy(dAtA[i:], m.AcceptorIdentity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.AcceptorIdentity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawAclRecordWithId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawAclRecordWithId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawAclRecordWithId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintAclrecord(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrevId) > 0 {
		i -= len(m.PrevId)
		copy(dAtA[i:], m.PrevId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.PrevId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclRoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclRoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclRoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IdentitySignature) > 0 {
		i -= len(m.IdentitySignature)
		copy(dAtA[i:], m.IdentitySignature)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.IdentitySignature)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timestamp != 0 {
		i = encodeVarintAclrecord(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EncryptedReadKey) > 0 {
		i -= len(m.EncryptedReadKey)
		copy(dAtA[i:], m.EncryptedReadKey)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.EncryptedReadKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SpaceId) > 0 {
		i -= len(m.SpaceId)
		copy(dAtA[i:], m.SpaceId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.SpaceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MasterKey) > 0 {
		i -= len(m.MasterKey)
		copy(dAtA[i:], m.MasterKey)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.MasterKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountInvite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountInvite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InviteKey) > 0 {
		i -= len(m.InviteKey)
		copy(dAtA[i:], m.InviteKey)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.InviteKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountRequestJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountRequestJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountRequestJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InviteIdentitySignature) > 0 {
		i -= len(m.InviteIdentitySignature)
		copy(dAtA[i:], m.InviteIdentitySignature)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.InviteIdentitySignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InviteRecordId) > 0 {
		i -= len(m.InviteRecordId)
		copy(dAtA[i:], m.InviteRecordId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.InviteRecordId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InviteIdentity) > 0 {
		i -= len(m.InviteIdentity)
		copy(dAtA[i:], m.InviteIdentity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.InviteIdentity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountRequestAccept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountRequestAccept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountRequestAccept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintAclrecord(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EncryptedReadKeys) > 0 {
		i -= len(m.EncryptedReadKeys)
		copy(dAtA[i:], m.EncryptedReadKeys)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.EncryptedReadKeys)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestRecordId) > 0 {
		i -= len(m.RequestRecordId)
		copy(dAtA[i:], m.RequestRecordId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.RequestRecordId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountRequestDecline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountRequestDecline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountRequestDecline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestRecordId) > 0 {
		i -= len(m.RequestRecordId)
		copy(dAtA[i:], m.RequestRecordId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.RequestRecordId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountInviteRevoke) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountInviteRevoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountInviteRevoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InviteRecordId) > 0 {
		i -= len(m.InviteRecordId)
		copy(dAtA[i:], m.InviteRecordId)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.InviteRecordId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclReadKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclReadKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclReadKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReadKeys) > 0 {
		for k := range m.ReadKeys {
			v := m.ReadKeys[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintAclrecord(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAclrecord(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAclrecord(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclEncryptedReadKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclEncryptedReadKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclEncryptedReadKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedReadKey) > 0 {
		i -= len(m.EncryptedReadKey)
		copy(dAtA[i:], m.EncryptedReadKey)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.EncryptedReadKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountPermissionChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountPermissionChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountPermissionChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != 0 {
		i = encodeVarintAclrecord(dAtA, i, uint64(m.Permissions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclReadKeyChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclReadKeyChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclReadKeyChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountKeys) > 0 {
		for iNdEx := len(m.AccountKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccountKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclrecord(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclAccountRemove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAccountRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAccountRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountKeys) > 0 {
		for iNdEx := len(m.AccountKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccountKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclrecord(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintAclrecord(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclContentValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclContentValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclContentValue_Invite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_Invite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Invite != nil {
		{
			size, err := m.Invite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_InviteRevoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_InviteRevoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InviteRevoke != nil {
		{
			size, err := m.InviteRevoke.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_RequestJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_RequestJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestJoin != nil {
		{
			size, err := m.RequestJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_RequestAccept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_RequestAccept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestAccept != nil {
		{
			size, err := m.RequestAccept.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_PermissionChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_PermissionChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PermissionChange != nil {
		{
			size, err := m.PermissionChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_AccountRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_AccountRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AccountRemove != nil {
		{
			size, err := m.AccountRemove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_ReadKeyChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_ReadKeyChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReadKeyChange != nil {
		{
			size, err := m.ReadKeyChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AclContentValue_RequestDecline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclContentValue_RequestDecline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestDecline != nil {
		{
			size, err := m.RequestDecline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *AclData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AclContent) > 0 {
		for iNdEx := len(m.AclContent) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AclContent[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclrecord(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclSyncMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSyncMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclSyncMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AclSyncContentValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclSyncContentValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclSyncContentValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AclSyncContentValue_AddRecords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclSyncContentValue_AddRecords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddRecords != nil {
		{
			size, err := m.AddRecords.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAclrecord(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AclAddRecords) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AclAddRecords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AclAddRecords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAclrecord(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAclrecord(dAtA []byte, offset int, v uint64) int {
	offset -= sovAclrecord(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RawAclRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.AcceptorIdentity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.AcceptorSignature)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *RawAclRecordWithId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrevId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAclrecord(uint64(m.Timestamp))
	}
	return n
}

func (m *AclRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.MasterKey)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.SpaceId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.EncryptedReadKey)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAclrecord(uint64(m.Timestamp))
	}
	l = len(m.IdentitySignature)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclAccountInvite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InviteKey)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclAccountRequestJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InviteIdentity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.InviteRecordId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.InviteIdentitySignature)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclAccountRequestAccept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.RequestRecordId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.EncryptedReadKeys)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	if m.Permissions != 0 {
		n += 1 + sovAclrecord(uint64(m.Permissions))
	}
	return n
}

func (m *AclAccountRequestDecline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestRecordId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclAccountInviteRevoke) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InviteRecordId)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclReadKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReadKeys) > 0 {
		for k, v := range m.ReadKeys {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovAclrecord(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovAclrecord(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAclrecord(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AclEncryptedReadKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	l = len(m.EncryptedReadKey)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclAccountPermissionChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	if m.Permissions != 0 {
		n += 1 + sovAclrecord(uint64(m.Permissions))
	}
	return n
}

func (m *AclReadKeyChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AccountKeys) > 0 {
		for _, e := range m.AccountKeys {
			l = e.Size()
			n += 1 + l + sovAclrecord(uint64(l))
		}
	}
	return n
}

func (m *AclAccountRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovAclrecord(uint64(l))
	}
	if len(m.AccountKeys) > 0 {
		for _, e := range m.AccountKeys {
			l = e.Size()
			n += 1 + l + sovAclrecord(uint64(l))
		}
	}
	return n
}

func (m *AclContentValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *AclContentValue_Invite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Invite != nil {
		l = m.Invite.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_InviteRevoke) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InviteRevoke != nil {
		l = m.InviteRevoke.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_RequestJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestJoin != nil {
		l = m.RequestJoin.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_RequestAccept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestAccept != nil {
		l = m.RequestAccept.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_PermissionChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PermissionChange != nil {
		l = m.PermissionChange.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_AccountRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRemove != nil {
		l = m.AccountRemove.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_ReadKeyChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadKeyChange != nil {
		l = m.ReadKeyChange.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclContentValue_RequestDecline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestDecline != nil {
		l = m.RequestDecline.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AclContent) > 0 {
		for _, e := range m.AclContent {
			l = e.Size()
			n += 1 + l + sovAclrecord(uint64(l))
		}
	}
	return n
}

func (m *AclSyncMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}

func (m *AclSyncContentValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *AclSyncContentValue_AddRecords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddRecords != nil {
		l = m.AddRecords.Size()
		n += 1 + l + sovAclrecord(uint64(l))
	}
	return n
}
func (m *AclAddRecords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovAclrecord(uint64(l))
		}
	}
	return n
}

func sovAclrecord(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAclrecord(x uint64) (n int) {
	return sovAclrecord(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawAclRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawAclRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawAclRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptorIdentity = append(m.AcceptorIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.AcceptorIdentity == nil {
				m.AcceptorIdentity = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptorSignature = append(m.AcceptorSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.AcceptorSignature == nil {
				m.AcceptorSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawAclRecordWithId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawAclRecordWithId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawAclRecordWithId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclRoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclRoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclRoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterKey = append(m.MasterKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MasterKey == nil {
				m.MasterKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKey = append(m.EncryptedReadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedReadKey == nil {
				m.EncryptedReadKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentitySignature = append(m.IdentitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.IdentitySignature == nil {
				m.IdentitySignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteKey = append(m.InviteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.InviteKey == nil {
				m.InviteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountRequestJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountRequestJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountRequestJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteIdentity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteIdentity = append(m.InviteIdentity[:0], dAtA[iNdEx:postIndex]...)
			if m.InviteIdentity == nil {
				m.InviteIdentity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteRecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteRecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteIdentitySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteIdentitySignature = append(m.InviteIdentitySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.InviteIdentitySignature == nil {
				m.InviteIdentitySignature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountRequestAccept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountRequestAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountRequestAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestRecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestRecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKeys = append(m.EncryptedReadKeys[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedReadKeys == nil {
				m.EncryptedReadKeys = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= AclUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountRequestDecline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountRequestDecline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountRequestDecline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestRecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestRecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountInviteRevoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountInviteRevoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountInviteRevoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteRecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteRecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclReadKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclReadKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclReadKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadKeys == nil {
				m.ReadKeys = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAclrecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAclrecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAclrecord
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAclrecord
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAclrecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthAclrecord
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthAclrecord
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAclrecord(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAclrecord
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadKeys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclEncryptedReadKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclEncryptedReadKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclEncryptedReadKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedReadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedReadKey = append(m.EncryptedReadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedReadKey == nil {
				m.EncryptedReadKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountPermissionChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountPermissionChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountPermissionChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			m.Permissions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permissions |= AclUserPermissions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclReadKeyChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclReadKeyChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclReadKeyChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountKeys = append(m.AccountKeys, &AclEncryptedReadKey{})
			if err := m.AccountKeys[len(m.AccountKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAccountRemove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAccountRemove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAccountRemove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountKeys = append(m.AccountKeys, &AclEncryptedReadKey{})
			if err := m.AccountKeys[len(m.AccountKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclContentValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclContentValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclContentValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountInvite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_Invite{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteRevoke", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountInviteRevoke{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_InviteRevoke{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountRequestJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_RequestJoin{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestAccept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountRequestAccept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_RequestAccept{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountPermissionChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_PermissionChange{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountRemove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_AccountRemove{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeyChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclReadKeyChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_ReadKeyChange{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestDecline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAccountRequestDecline{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclContentValue_RequestDecline{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AclContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AclContent = append(m.AclContent, &AclContentValue{})
			if err := m.AclContent[len(m.AclContent)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSyncMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSyncMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSyncMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &AclSyncContentValue{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclSyncContentValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclSyncContentValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclSyncContentValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AclAddRecords{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AclSyncContentValue_AddRecords{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AclAddRecords) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AclAddRecords: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AclAddRecords: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAclrecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAclrecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, &RawAclRecordWithId{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAclrecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAclrecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAclrecord(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAclrecord
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAclrecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAclrecord
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAclrecord
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAclrecord
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAclrecord        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAclrecord          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAclrecord = fmt.Errorf("proto: unexpected end of group")
)
